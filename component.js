const t=t=>e=>typeof e===t,e=t("object"),s=t("function"),n=t=>null==t,c=t=>null!=t,r=t=>c(t)&&(e(t)||s(t)),o=(t,e)=>s(t[e]),a=t=>t.nodeType!==Node.COMMENT_NODE,i=t=>n(t)?[]:[t],l=(t,e)=>({elements:e,host:t,map:s=>l(t,e.map((e=>s(t,e))))}),d=t=>({run:()=>t()});let u;const h=t=>r(t)&&o(t,"set"),f=t=>h(t)||(t=>r(t)&&o(t,"run")&&"effects"in t)(t),p=t=>{const e=()=>(u&&e.effects.add(u),t);return e.effects=new Set,e.set=n=>{const c=t;t=s(n)&&!f(n)?n(t):n,Object.is(t,c)||(t=>{for(const e of t)e.run()})(e.effects)},e},b=t=>{const e=new Map,n=()=>{const c=u;u=n;const r=t(((t,s)=>{e.has(t)||e.set(t,new Set),e.get(t)?.add(s)}));for(const t of e.values()){for(const e of t)e.run();t.clear()}u=c,s(r)&&queueMicrotask(r)};n.run=()=>n(),n.targets=e,n()},m=t=>({map:()=>m(t),fold:e=>e(t),catch:e=>e(t)}),g=t=>{try{return e=t(),{map:t=>g((()=>t(e))),fold:(t,s)=>s(e),catch:()=>{}}}catch(t){return m(t)}var e},x="context-request";class y extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(x,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const C="error",v=(t,e,s="debug")=>((t=>"warn"===t||t===C)(s)&&console[s](e,t),t),k=t=>s(t)?k(t()):t,E=t=>t.shadowRoot||t;class M extends HTMLElement{static registry=customElements;static attributeMap={};static consumedContexts;static providedContexts;static define(t){g((()=>!this.registry.get(t)&&this.registry.define(t,this))).catch((e=>v(t,e.message,C)))}#t=new Map;attributeChangedCallback(t,e,n){if(n===e)return;const c=this.constructor.attributeMap[t];this.set(t,s(c)?c(i(n),this,e)[0]:n)}connectedCallback(){const t=this.constructor,e=t.consumedContexts||[];for(const t of e)this.set(String(t),void 0);setTimeout((()=>{for(const t of e)this.dispatchEvent(new y(t,(e=>this.set(String(t),e))))}));const n=t.providedContexts||[];n.length&&this.addEventListener(x,(t=>{const{context:e,callback:c}=t;n.includes(e)&&s(c)&&(t.stopPropagation(),c(this.#t.get(String(e))))}))}disconnectedCallback(){}has(t){return this.#t.has(t)}get(t){return k(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){if(s){const s=this.#t.get(t);h(s)&&s.set(e)}}else this.#t.set(t,f(e)?e:p(e))}delete(t){return this.#t.delete(t)}first(t){return l(this,i(E(this).querySelector(t)))}all(t){return l(this,Array.from(E(this).querySelectorAll(t)))}async pass(t,e){if(await this.constructor.registry.whenDefined(t.localName),o(t,"set"))for(const[n,c]of Object.entries(e))t.set(n,f(c)?c:s(c)?p(c):this.#t.get(c));else v(t,"Expected UIElement",C)}signal(t){return this.#t.get(t)}}const w=t=>async(e,n)=>{if(await e.constructor.registry.whenDefined(n.localName),o(n,"set"))for(const[c,r]of Object.entries(t))n.set(c,f(r)?r:s(r)?p(r):e.signal(r));else v(n,"Expected UIElement",C)},N=t=>Number.isFinite(t)?t:void 0,S=t=>[c(t[0])],A=t=>t.map((t=>parseInt(t,10))).map(N),O=t=>t.map(parseFloat).map(N),L=t=>t,j=t=>t.map((t=>g((()=>JSON.parse(t))).fold((t=>v(void 0,`Failed to parse JSON: ${t.message}`,C)),(t=>t)))),T=(t,e,s)=>(n,c)=>(c.addEventListener(t,(t=>n.set(e,(e=>s(t,e))))),c),q=(t,e,s,c,r,o)=>{const a=d(r);return t.set(e,c,!1),b((c=>{if(t.has(e)){const r=t.get(e);n(r)?c(s,a):c(s,(t=>d(o(t)))(r))}})),s},D=t=>(e,s)=>{const n=s.textContent||"",c=t=>()=>{Array.from(s.childNodes).filter(a).forEach((t=>t.remove())),s.append(document.createTextNode(t))};return q(e,t,s,n,c(n),c)},F=(t,e=t)=>(s,n)=>{const c=e=>()=>n[t]=e;return q(s,e,n,n[t],c(null),c)},I=(t,e=t)=>(s,n)=>q(s,e,n,n.getAttribute(t),(()=>n.removeAttribute(t)),(e=>()=>n.setAttribute(t,e))),J=(t,e=t)=>(s,n)=>{const c=e=>()=>n.toggleAttribute(t,e);return q(s,e,n,n.hasAttribute(t),c(!1),c)},P=(t,e=t)=>(s,n)=>q(s,e,n,n.classList.contains(t),(()=>n.classList.remove(t)),(e=>()=>n.classList.toggle(t,e))),U=(t,e=t)=>(s,n)=>q(s,e,n,n.style[t],(()=>n.style.removeProperty(t)),(e=>()=>n.style[t]=String(e))),H=(t,e={},n,c=M)=>{const o=class extends c{static observedAttributes=r(e.attributeMap)?Object.keys(e.attributeMap):[];static attributeMap=e.attributeMap||{};static providedContexts=e.providedContexts||[];static consumedContexts=e.consumedContexts||[];disconnect;connectedCallback(){if(super.connectedCallback(),!s(n))return;const t=n(this);s(t)&&(this.disconnect=t)}disconnectedCallback(){"disconnectedCallback"in c&&super.disconnectedCallback(),this.disconnect()}};return o.define(t),o};export{M as UIElement,S as asBoolean,A as asInteger,j as asJSON,O as asNumber,L as asString,H as component,b as effect,d as io,i as maybe,T as on,w as pass,I as setAttribute,F as setProperty,U as setStyle,D as setText,J as toggleAttribute,P as toggleClass,l as ui};
