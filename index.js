const t=t=>e=>typeof e===t,e=t("object"),s=t("function"),n=t=>(t=>null!=t)(t)&&(e(t)||s(t)),c=(t,e)=>s(t[e]),o=()=>new Proxy({},{get:(t,e)=>"toString"===e?()=>"":"fold"===e?t=>t():()=>o()}),r=t=>({map:e=>r(e(t)),fold:(e,s)=>s(t),toString:()=>String(t)}),a=t=>(t=>null==t)(t)?o():r(t),i=t=>({map:()=>i(t),fold:e=>e(t),catch:e=>e(t)}),l=t=>{try{return e=t(),{map:t=>l((()=>t(e))),fold:(t,s)=>s(e),catch:()=>{}}}catch(t){return i(t)}var e};let h;const u=t=>n(t)&&c(t,"set"),d=t=>u(t)||(t=>n(t)&&c(t,"run")&&"effects"in t)(t),f=t=>{const e=()=>(h&&e.effects.add(h),t);return e.effects=new Set,e.set=n=>{const c=t;t=s(n)&&!d(n)?n(t):n,Object.is(t,c)||(t=>{for(const e of t)e.run()})(e.effects)},e},g=t=>{const e=new Map,n=()=>{const c=h;h=n;const o=t(((t,s)=>{e.has(t)||e.set(t,new Set),e.get(t)?.add(s)}));for(const t of e.values()){for(const e of t)e();t.clear()}h=c,s(o)&&queueMicrotask(o)};n.run=()=>n(),n.targets=e,n()},b="context-request";class p extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(b,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const m="error",x=(t,e,s="debug")=>((t=>"warn"===t||t===m)(s)&&console[s](e,t),t),w=t=>s(t)?w(t()):t;class v extends HTMLElement{static registry=customElements;static attributeMap={};static consumedContexts;static providedContexts;static define(t){l((()=>!this.registry.get(t)&&this.registry.define(t,this))).catch((e=>x(t,e.message,m)))}#t=new Map;attributeChangedCallback(t,e,n){if(n===e)return;const c=this.constructor.attributeMap[t];this.set(t,s(c)?c(a(n),this,e).fold((()=>{}),(t=>t)):n)}connectedCallback(){const t=this.constructor,e=t.consumedContexts||[];for(const t of e)this.set(String(t),void 0);setTimeout((()=>{for(const t of e)this.dispatchEvent(new p(t,(e=>this.set(String(t),e))))}));const n=t.providedContexts||[];n.length&&this.addEventListener(b,(t=>{const{context:e,callback:c}=t;n.includes(e)&&s(c)&&(t.stopPropagation(),c(this.#t.get(String(e))))}))}disconnectedCallback(){}has(t){return this.#t.has(t)}get(t){return w(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){if(s){const s=this.#t.get(t);u(s)&&s.set(e)}}else this.#t.set(t,d(e)?e:f(e))}delete(t){return this.#t.delete(t)}async pass(t,e){if(await this.constructor.registry.whenDefined(t.localName),c(t,"set"))for(const[n,c]of Object.entries(e))t.set(n,d(c)?c:s(c)?f(c):this.#t.get(c));else x(t,"Expected UIElement",m)}signal(t){return this.#t.get(t)}}export{v as UIElement,g as effect,a as maybe};
