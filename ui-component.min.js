let t;const e=t=>"function"==typeof t,s=t=>e(t)&&e(t.set),o=o=>{const a=()=>(t&&a.effects.add(t),o);return a.effects=new Set,a.set=t=>{const c=o;if(o=e(t)&&!s(t)?t(c):t,!Object.is(o,c))for(const t of a.effects)t()},a},a=s=>{const o=new Map,a=()=>{const c=t;t=a;const n=s(((t,e)=>{!o.has(t)&&o.set(t,new Set),o.get(t).add(e)}));t=c,queueMicrotask((()=>{for(const t of o.values())for(const e of t)e();e(n)&&n()}))};a.targets=o,a()},c="context-request";class n extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(c,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class r extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,s,o){if(o!==s){const a=this.attributeMap[t],[c,n]=Array.isArray(a)?a:[t,a];this.set(c,e(n)?n(o,this,s):o)}}connectedCallback(){const t=Object.getPrototypeOf(this),s=t.providedContexts||[];s.length&&this.addEventListener(c,(t=>{const{context:o,callback:a}=t;s.includes(o)&&e(a)&&(t.stopPropagation(),a(this.#t.get(o)))})),setTimeout((()=>{t.consumedContexts?.forEach((t=>{const s=new n(t,(s=>{const o=this.contextMap[t],[a,c]=Array.isArray(o)?o:[t,o];this.#t.set(a||t,e(c)?c(s,this):s)}));this.dispatchEvent(s)}))}))}has(t){return this.#t.has(t)}get(t){const s=t=>e(t)?s(t()):t;return s(this.#t.get(t))}set(t,e,a=!0){if(this.#t.has(t)){const o=this.#t.get(t);a&&s(o)&&o.set(e)}else{const a=s(e)?e:o(e);this.#t.set(t,a)}}delete(t){return this.#t.delete(t)}async pass(t,s,a=customElements){await a.whenDefined(t.localName);for(const[a,c]of Object.entries(s))t.set(a,o(e(c)?c:this.#t.get(c)))}targets(t){const e=new Set;for(const s of this.#t.get(t).effects)for(const t of s.targets.keys())e.add(t);return e}}const i=t=>"string"==typeof t,l=t=>parseInt(t,10),f=t=>parseFloat(t),u=t=>t,h="text",d="prop",g="attr",b="class",p="style",m=t=>void 0!==t,y=t=>{const e=t.shadowRoot||t,s=()=>t;var o;return s.first=t=>{const s=e.querySelector(t);return s&&y(s)},s.all=t=>Array.from(e.querySelectorAll(t)).map((t=>y(t))),s[h]={get:()=>t.textContent?.trim()||"",set:e=>{Array.from(t.childNodes).filter((t=>t.nodeType!==Node.COMMENT_NODE)).forEach((t=>t.remove())),t.append(document.createTextNode(e))}},s[d]={get:e=>t[e],set:(e,s)=>t[e]=s},s[g]={get:e=>t.getAttribute(e),set:(e,s)=>"boolean"==typeof s?t.toggleAttribute(e,s):m(s)?t.setAttribute(e,s):t.removeAttribute(e)},s[b]={get:e=>t.classList.contains(e),set:(e,s)=>t.classList.toggle(e,s)},((o=t)instanceof HTMLElement||o instanceof SVGElement||o instanceof MathMLElement)&&(s[p]={get:e=>t.style.getPropertyValue(e),set:(e,s)=>m(s)?t.style.setProperty(e,s):t.style.removeProperty(e)}),s},E=(t,e,s)=>{const o=`data-${t.localName}-${e}`,a=t=>{s(t,t.getAttribute(o)),t.removeAttribute(o)};t.hasAttribute(o)&&a(t);for(const e of t.querySelectorAll(`[${o}]`))a(e)},v="hover",A="focus",x=(t,e={},s,o)=>{const c=class extends r{static observedAttributes=Object.keys(e);attributeMap=e;connectedCallback(){var t;super.connectedCallback(),s&&s(this),t=this,[h,d,g,b,p].forEach((e=>{E(t,e,e===h?(s,o)=>{const c=o.trim(),n=y(s)[e],r=n.get();t.set(c,r,!1),a((e=>{if(t.has(c)){const o=t.get(c);e(s,(()=>n.set(m(o)?o:r)))}}))}:(s,o)=>{const c=(t,e)=>t.split(e).map((t=>t.trim()));c(o,";").forEach((o=>{const[n,r=n]=c(o,":"),i=y(s)[e];t.set(r,i.get(),!1),a((e=>{if(t.has(r)){const o=t.get(r);e(s,(()=>i.set(n,o)))}}))}))})})),((t,e="ui-effect")=>{[v,A].forEach((s=>{const[o,a]=s===v?["mouseenter","mouseleave"]:["focus","blur"];E(t,s,((s,c)=>{const n=c.trim(),r=(o,a)=>s.addEventListener(o,(()=>{for(const s of t.targets(n))s.classList.toggle(e,a)}));r(o,!0),r(a,!1)}))}))})(this)}disconnectedCallback(){o&&o(this)}};return c.define(t),c};export{r as UIElement,i as asBoolean,l as asInteger,f as asNumber,u as asString,x as default,a as effect,y as uiRef};