<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UIElement Test</title>
</head>
<body>

  <style>
    my-counter {
      display: flex;
      flex-direction: row;
      gap: 1rem;

      p {
        margin-block: 0.2rem;
      }
    }

    .ui-effect {
      outline: 1px dotted red;
      outline-offset: 2px;
    }
  </style>

  <void-component id="void">
    <h1>Hello from Server</h1>
  </void-component>
  <void-component id="void2">
    <h1>Hello from Server</h1>
  </void-component>
  <causal-component id="causal">
    <h1 data-causal-component-text="heading">Hello from Server</h1>
  </causal-component>
  <causal-component id="causal-with-ignored-attribute" heading="Hello from Attribute">
    <h1 data-causal-component-text="heading">Hello from Server</h1>
  </causal-component>
  <updating-component id="updating">
    <h1 data-updating-component-text="title">Hello from Server</h1>
    <p>Number of unread messages: <span data-updating-component-text="count"></span></p>
  </updating-component>
  <updating-component id="updating-with-string-attribute" heading="Hello from Attribute">
    <h1 data-updating-component-text="title">Hello from Server</h1>
    <p>Number of unread messages: <span data-updating-component-text="count"></span></p>
  </updating-component>
  <updating-component id="updating-with-number-attribute" count="42" step="0.1" value="3.14">
    <h1 data-updating-component-text="title">Hello from Server</h1>
    <p>Number of unread messages: <span data-updating-component-text="count"></span></p>
    <input type="number" data-updating-component-attr="step; value" />
  </updating-component>
  <updating-component id="updating-with-boolean-attribute" selected>
    <h1 data-updating-component-text="title" data-updating-component-class="selected">Hello from Server</h1>
    <p>Number of unread messages: <span data-updating-component-text="count"></span></p>
  </updating-component>
  <child-component id="orphan">
    <h1 data-child-component-text="heading">Hello from Server</h1>
    <p data-child-component-text="text">Text from Server</p>
  </child-component>
  <parent-component id="parent" heading="Hello from Attribute">
    <child-component id="child">
      <h1 data-child-component-text="heading">Hello from Server</h1>
      <p data-child-component-text="text">Text from Server</p>
    </child-component>
  </parent-component>
  <my-counter value="42">
    <p>Count: <span class="value" data-my-counter-text="value">42</span></p>
    <p>Parity: <span class="parity" data-my-counter-text="parity">even</span></p>
    <p>Double: <span class="double" data-my-counter-text="double">84</span></p>
    <div>
      <button class="decrement" data-my-counter-hover="value">â€“</button>
      <button class="increment" data-my-counter-hover="value">+</button>
    </div>
  </my-counter>
  <greeting-configurator>
    <input-field class="first">
      <input type="text" name="first" value="Jane" data-input-field-focus="value" />
    </input-field>
    <input-field class="last">
      <input type="text" name="last" value="Doe" data-input-field-focus="value" />
    </input-field>
    <input-checkbox>
      <input type="checkbox" name="fullname" data-input-checkbox-hover="checked" />
    </input-checkbox>
    <hello-world>
      <p>
        <span class="greeting" data-hello-world-text="greeting">Hello</span>
        <span class="name" data-hello-world-text="name">World</span>
      </p>
    </hello-world>
  </greeting-configurator>

  <script type="module">
    import { runTests } from '@web/test-runner-mocha';
    import { assert } from '@esm-bundle/chai';
    import { effect } from '../lib/cause-effect.js';
    import { asBoolean, asInteger, asNumber, asString } from '../index.js';
    import { component } from '../lib/dom-utils.js';

    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
    const paint = () => new Promise(resolve => requestAnimationFrame(resolve));
    const normalizeText = text => text.replace(/\s+/g, ' ').trim();

    // (class extends UIElement { /* debug = true */ }).define('void-component');
    component('void-component');

    /* class CausalComponent extends UIElement {
      // debug = true;

      connectedCallback() {
        this.set('heading', 'Hello from Internal State');
        this.autoEffects();
        // effect(() => setText(this.querySelector('h1'), this.get('heading')));
        // effect(() => setText(this.querySelector('h1'), this.state.heading));
      }

    }
    CausalComponent.define('causal-component'); */

    component('causal-component', {}, el => {
      el.set('heading', 'Hello from Internal State');
    });

    /* class UpdatingComponent extends DebugElement {
      static observedAttributes = ['heading', 'count', 'step', 'value', 'selected'];
      attributeMap = {
        heading: ['title'],
        count: asInteger,
        step: asNumber,
        value: (v, el) => Number.isInteger(el.get('step')) ? parseInt(v, 10) : parseFloat(v),
        selected: asBoolean,
      };
      debug = (this.id === 'updating-with-number-attribute'); // true;

      connectedCallback() {
        this.autoEffects();
        / * const heading = this.querySelector('h1');
        const badge = this.querySelector('span');
        const input = this.querySelector('input');

        effect(() => this.has('title') && setText(heading, this.get('title')));
        effect(() => this.has('count') && setText(badge, this.get('count')));
        effect(() => this.has('step') && setAttr(input, 'step', this.get('step')));
        effect(() => this.has('value') && setAttr(input, 'value', this.get('value')));
        effect(() => this.has('selected') && setClass(heading, 'selected', this.get('selected'))); * /
      }
    }
    UpdatingComponent.define('updating-component'); */

    component('updating-component', {
      heading: ['title'],
      count: asInteger,
      step: asNumber,
      value: (v, el) => Number.isInteger(el.get('step')) ? parseInt(v, 10) : parseFloat(v),
      selected: asBoolean,
    });

    /* class ParentComponent extends UIElement {
      static observedAttributes = ['heading'];
      // debug = true;

      connectedCallback() {
        this.pass(this.querySelector('child-component'), {
          heading: 'heading',
          text: () => this.get('heading').toUpperCase(),
        });
      }
    }
    ParentComponent.define('parent-component'); */

    component('parent-component', { heading: asString }, el => {
      el.pass(el.querySelector('child-component'), {
        heading: 'heading',
        text: () => el.get('heading').toUpperCase(),
      });
    });

    /* class ChildComponent extends UIElement {
      // debug = true;

      connectedCallback() {
        this.autoEffects();
        // effect(() => setText(this.querySelector('h1'), this.get('heading') || null));
        // effect(() => setText(this.querySelector('p'), this.get('text') || null));
      }
    }
    ChildComponent.define('child-component'); */

    component('child-component');

    /* class MyCounter extends DebugElement {
      static observedAttributes = ['value'];
      static attributeMap = { value: asInteger };
      // debug = true;

      connectedCallback() {
        // this.querySelector('.decrement').onclick = () => this.set('value', v => --v);
        // this.querySelector('.increment').onclick = () => this.set('value', v => ++v);

        this.set('parity', () => this.get('value') % 2 ? 'odd' : 'even');
        this.set('double', () => this.get('value') * 2);
        this.autoEffects();

        / * const s = this.state;
        this.querySelector('.decrement').onclick = () => s.value--;
        this.querySelector('.increment').onclick = () => s.value++;

        effect(() => {
          const value = s.value;
          setText(this.querySelector('.value'), value);
          setText(this.querySelector('.parity'), value % 2 ? false : true);
          setText(this.querySelector('.double'), value * 2);
        }); * /
        super.connectedCallback(); // enable for debugging
      }
    }
    MyCounter.define('my-counter'); */

    component('my-counter', { value: asInteger }, el => {
      el.set('parity', () => el.get('value') % 2 ? 'odd' : 'even');
      el.set('double', () => el.get('value') * 2);
      el.querySelector('.decrement').onclick = () => el.set('value', v => --v);
      el.querySelector('.increment').onclick = () => el.set('value', v => ++v);
    });

    /* class GreetingConfigurator extends UIElement {
      connectedCallback() {
        const first = this.querySelector('.first');
        const last = this.querySelector('.last');
        const useFullname = this.querySelector('input-checkbox');
        const helloWorld = this.querySelector('hello-world');
        this.pass(helloWorld, {
          name: () => useFullname.get('checked') ? `${first.get('value')} ${last.get('value')}` : first.get('value'),
        });
      }
    }
    GreetingConfigurator.define('greeting-configurator'); */

    component('greeting-configurator', {}, el => {
      const first = el.querySelector('.first');
      const last = el.querySelector('.last');
      const useFullname = el.querySelector('input-checkbox');
      el.pass(el.querySelector('hello-world'), {
        name: () => useFullname.get('checked') ? `${first.get('value')} ${last.get('value')}` : first.get('value'),
      });
    });

    /* class HelloWorld extends UIElement {
      static observedAttributes = ['greeting'];

      connectedCallback() {
        // const greeting = this.querySelector('.greeting');
        // const name = this.querySelector('.name');
        // const defaultName = name.textContent;
        this.set('greeting', this.querySelector('.greeting').textContent, false);
        this.autoEffects();
        // effect(() => setText(greeting, this.get('greeting')));
        // effect(() => setText(name, this.get('name') || defaultName));
      }
    }
    HelloWorld.define('hello-world'); */

    component('hello-world', { greeting: asString }, el => {
      el.set('greeting', el.querySelector('.greeting').textContent, false);
    });

    /* class InputField extends UIElement {

      connectedCallback() {
        const input = this.querySelector('input');
        this.set('value', input.value);
        input.onchange = () => this.set('value', input.value);
      }
    }
    InputField.define('input-field'); */

    component('input-field', {}, el => {
      const input = el.querySelector('input');
      el.set('value', input.value);
      input.onchange = () => el.set('value', input.value);
    });

    /* class InputCheckbox extends UIElement {

      connectedCallback() {
        const input = this.querySelector('input');
        this.set('checked', input.checked);
        input.onchange = () => this.set('checked', input.checked);
      }
    }
    InputCheckbox.define('input-checkbox'); */

    component('input-checkbox', {}, el => {
      const input = el.querySelector('input');
      el.set('checked', input.checked);
      input.onchange = () => el.set('checked', input.checked);
    });

    runTests(() => {

      describe('UIElement', function () {

        describe('Void component', function () {

          it('should be an instance of HTMLElement', async function () {
            const voidComponent = document.getElementById('void');
            assert.instanceOf(voidComponent, HTMLElement);
            assert.equal(voidComponent.localName, 'void-component');
          });

          it('should do nothing at all', async function () {
            const voidComponent = document.getElementById('void');
            await paint();
            const textContent = normalizeText(voidComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Server', 'Should not change server-side rendered heading');
          });

          it('should return false with has() for unset state', async function () {
            const voidComponent = document.getElementById('void');
            assert.equal(voidComponent.has('test'), false);
            assert.equal(voidComponent.hasOwnProperty('test'), false);
          });

          it('should create a new state with set()', async function () {
            const voidComponent = document.getElementById('void');
            voidComponent.set('foo', 'foo');
            await paint();
            assert.equal(voidComponent.get('foo'), 'foo');
          });

          it('should return true with has() for set state', async function () {
            const voidComponent = document.getElementById('void');
            voidComponent.set('bar', 'bar');
            await paint();
            assert.equal(voidComponent.has('bar'), true);
          });

          it('should update an existing state with set()', async function () {
            const voidComponent = document.getElementById('void');
            for (let i = 1; i <= 10; i++) {
              voidComponent.set('test', i);
            }
            await paint();
            assert.equal(voidComponent.get('test'), 10);
          });

          it('should trigger dependent effects with set()', async function () {
            const voidComponent = document.getElementById('void2');
            voidComponent.set('foo', 'test', false);
            let effectDidRun = false;
            effect(() => {
              voidComponent.get('foo');
              effectDidRun = true;
            });
            await paint();
            assert.isTrue(effectDidRun);
          });

          it('should trigger dependent effects with set() again after change', async function () {
            const voidComponent = document.getElementById('void2');
            voidComponent.set('foo', 'test', false);
            let effectDidRun = false;
            effect(() => {
              voidComponent.get('foo');
              effectDidRun = true;
            });
            voidComponent.set('foo', 'bar');
            await paint();
            assert.isTrue(effectDidRun);
          });

          /* it('repeated set() should trigger dependent effect only once', async function () {
            const voidComponent = document.getElementById('void2');
            voidComponent.set('bar', 0);
            let result = 0;
            effect(() => {
              result++;
              voidComponent.get('bar');
            });
            for (let i = 1; i <= 10; i++) {
              voidComponent.set('bar', i);
            }
            await paint();
            assert.equal(result, 1);
          }); */

          it('should return false with has() for deleted state', async function () {
            const voidComponent = document.getElementById('void');
            voidComponent.set('test', 'test');
            voidComponent.delete('test');
            await paint();
            assert.equal(voidComponent.has('test'), false);
          });
        });

        describe('Causal component', function () {
          it('should update according to internal state', async function () {
            const causalComponent = document.getElementById('causal');
            await paint();
            const textContent = normalizeText(causalComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Internal State', 'Should have initial heading from internal state');
          });

          it('should update when state is set', async function () {
            const causalComponent = document.getElementById('causal');
            causalComponent.set('heading', 'Hello from State');
            await paint();
            const textContent = normalizeText(causalComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from State', 'Should update text content from setting heading state');
          });

          it('should update after a delay when state is set', async function () {
            const causalComponent = document.getElementById('causal');
            const delay = Math.floor(Math.random() * 1000);
            await wait(delay);
            causalComponent.set('heading', 'Hello from Delayed State');
            await paint();
            const textContent = normalizeText(causalComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Delayed State', 'Should update text content from setting heading state after a delay');
          });

          it('should ignore non-observed attributes', async function () {
            const causalComponent = document.getElementById('causal-with-ignored-attribute');
            await paint();
            const textContent = normalizeText(causalComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Internal State', 'Should have initial heading from internal state');
          });

          it('should throw a TypeError if effect handler is not a function', async function () {
            const causalComponent = document.getElementById('causal');
            if (causalComponent.debug) {
              try {
                const fn = async () => await effect(42);
                assert.throws(await fn(), TypeError);
              } catch (error) {
                // console.log(error);
              }
            }
          });
        });

        describe('Updating component', function () {
          it('should do nothing if attribute is not set', async function () {
            const updatingComponent = document.getElementById('updating');
            await paint();
            const textContent = normalizeText(updatingComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Server', 'Should not change server-side rendered heading');
          });

          it('should update from initial string attribute', async function () {
            const updatingComponent = document.getElementById('updating-with-string-attribute');
            await paint();
            const textContent = normalizeText(updatingComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Attribute', 'Should have initial heading from string attribute');
          });

          it('should update from initial integer number attribute', async function () {
            const updatingComponent = document.getElementById('updating-with-number-attribute');
            await paint();
            const textContent = normalizeText(updatingComponent.querySelector('span').textContent);
            assert.equal(textContent, '42', 'Should have initial count from numeric attribute');
          });

          it('should update from initial floating point number attribute', async function () {
            const updatingComponent = document.getElementById('updating-with-number-attribute');
            await paint();
            const stepAttribute = updatingComponent.querySelector('input').getAttribute('step');
            assert.equal(stepAttribute, '0.1', 'Should have initial step attribute from floating point number attribute');
          });

          it('should update from initial custom parser attribute', async function () {
            const updatingComponent = document.getElementById('updating-with-number-attribute');
            await paint();
            const valueAttribute = updatingComponent.querySelector('input').getAttribute('value');
            assert.equal(valueAttribute, '3.14', 'Should have initial value attribute from custom parser attribute');
          });

          it('should add class from boolean attribute', async function () {
            const updatingComponent = document.getElementById('updating-with-boolean-attribute');
            await paint();
            const className = updatingComponent.querySelector('h1').className;
            assert.equal(className, 'selected', 'Should have initial class from boolean attribute');
          });

          it('should update when string attribute set', async function () {
            const updatingComponent = document.getElementById('updating-with-string-attribute');
            updatingComponent.setAttribute('heading', 'Hello from Changed Attribute');
            await paint();
            const textContent = normalizeText(updatingComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from Changed Attribute', 'Should update text content from setting heading attribute');
          });

          it('should update when numeric attribute is set', async function () {
            const updatingComponent = document.getElementById('updating-with-number-attribute');
            updatingComponent.setAttribute('count', '0');
            await paint();
            const textContent = normalizeText(updatingComponent.querySelector('span').textContent);
            assert.equal(textContent, '0', 'Should update text content from setting count attribute');
          });

          it('should update when numeric state is set', async function () {
            const updatingComponent = document.getElementById('updating-with-number-attribute');
            updatingComponent.set('step', 1);
            await paint();
            const stepAttribute = updatingComponent.querySelector('input').getAttribute('step');
            assert.equal(stepAttribute, '1', 'Should update step attribute of input element from setting step state');
          });

          it('should update when numeric attribute is set, parsed as integer', async function () {
            const updatingComponent = document.getElementById('updating-with-number-attribute');
            updatingComponent.setAttribute('value', 1.14);
            await paint();
            const valueAttribute = updatingComponent.querySelector('input').getAttribute('value');
            assert.equal(valueAttribute, '1', 'Should update value attribute of input element from setting value attribute and parse it as defined');
          });

          it('should remove class when boolean attribute removed', async function () {
            const updatingComponent = document.getElementById('updating-with-boolean-attribute');
            updatingComponent.removeAttribute('selected');
            await paint();
            const className = updatingComponent.querySelector('h1').className;
            assert.equal(className, '', 'Should update text remove class from removing selected attribute');
          });

          it('should update when state is set', async function () {
            const updatingComponent = document.getElementById('updating-with-string-attribute');
            updatingComponent.set('title', 'Hello from State');
            await paint();
            const textContent = normalizeText(updatingComponent.querySelector('h1').textContent);
            assert.equal(textContent, 'Hello from State', 'Should update text content from setting title state');
          });
        });
        
        describe('Orphan child component', function () {

          it('should do nothing at all', async function () {
            const orphanComponent = document.getElementById('orphan');
            await paint();
            const headingContent = normalizeText(orphanComponent.querySelector('h1').textContent);
            const textContent = normalizeText(orphanComponent.querySelector('p').textContent);
            assert.equal(headingContent, 'Hello from Server', 'Should not change server-side rendered heading');
            assert.equal(textContent, 'Text from Server', 'Should not change server-side rendered text');
          });
        });

        describe('Child component', function () {

          it('should receive state from attribute of parent component', async function () {
            const childComponent = document.getElementById('child');
            await customElements.whenDefined(childComponent.localName);
            const headingContent = childComponent.querySelector('h1').textContent;
            assert.equal(headingContent, 'Hello from Attribute', 'Should have initial heading from attribute of parent component');
          });

          it('should receive derived state from attribute of parent component', async function () {
            const childComponent = document.getElementById('child');
            await customElements.whenDefined(childComponent.localName);
            const textContent = normalizeText(childComponent.querySelector('p').textContent);
            assert.equal(textContent, 'Hello from Attribute'.toUpperCase(), 'Should have initial text derived from attribute of parent component');
          });

          it('should receive passed and derived properties from changed attribute of parent component', async function () {
            const parentComponent = document.getElementById('parent');
            const childComponent = document.getElementById('child');
            parentComponent.setAttribute('heading', 'Hello from Changed Attribute');
            await paint();
            const headingContent = normalizeText(childComponent.querySelector('h1').textContent);
            const textContent = normalizeText(childComponent.querySelector('p').textContent);
            assert.equal(headingContent, 'Hello from Changed Attribute', 'Should have changed heading from attribute of parent component');
            assert.equal(textContent, 'Hello from Changed Attribute'.toUpperCase(), 'Should have changed text derived from attribute of parent component');
          });

          it('should change heading if inherited state is set', async function () {
            const parentComponent = document.getElementById('parent');
            const childComponent = document.getElementById('child');
            await customElements.whenDefined(childComponent.localName);
            parentComponent.set('heading', 'Hello from State on Parent');
            await paint();
            const headingContent = childComponent.querySelector('h1').textContent;
            assert.equal(headingContent, 'Hello from State on Parent', 'Should have changed heading from state of parent component');
          });

        });

        describe('My counter', function () {

          it('should increment and decrement', async function () {
            const counter = document.querySelector('my-counter');
            const decrement = counter.querySelector('.decrement');
            const increment = counter.querySelector('.increment');
            const value = counter.querySelector('.value');
            assert.equal(counter.get('value'), 42, 'Should have initial value from attribute');
            assert.equal(normalizeText(value.textContent), '42', 'Should have initial textContent from attribute');
            decrement.click();
            assert.equal(counter.get('value'), 41, 'Should decrement value');
            await paint();
            assert.equal(normalizeText(value.textContent), '41', 'Should have updated textContent from decrement');
            increment.click();
            assert.equal(counter.get('value'), 42, 'Should increment value');
            await paint();
            assert.equal(normalizeText(value.textContent), '42', 'Should have updated textContent from increment');
          });

          it('should update derived values', async function () {
            const counter = document.querySelector('my-counter');
            const decrement = counter.querySelector('.decrement');
            const increment = counter.querySelector('.increment');
            const parity = counter.querySelector('.parity');
            const double = counter.querySelector('.double');
            assert.equal(normalizeText(parity.textContent), 'even', 'Should have derived parity textContent from attribute');
            assert.equal(normalizeText(double.textContent), '84', 'Should have derived double textContent from attribute');
            decrement.click();
            await paint();
            assert.equal(normalizeText(parity.textContent), 'odd', 'Should have changed derived parity textContent');
            assert.equal(normalizeText(double.textContent), '82', 'Should have decremented derived double textContent');
          });

        });

        describe('Greeting Configurator', function () {

          it('should display greeting', async function () {
            const configurator = document.querySelector('greeting-configurator');
            const helloWorld = configurator.querySelector('hello-world');
            const greeting = helloWorld.querySelector('p');
            assert.equal(normalizeText(greeting.textContent), 'Hello Jane', 'Should have initial greeting');
            helloWorld.set('greeting', 'Hi');
            await paint();
            assert.equal(normalizeText(greeting.textContent), 'Hi Jane', 'Should have updated greeting from state');
          });

          it('should update name if first name changes', async function () {
            const configurator = document.querySelector('greeting-configurator');
            const first = configurator.querySelector('.first');
            const input = first.querySelector('input');
            const helloWorld = configurator.querySelector('hello-world');
            const greeting = helloWorld.querySelector('p');
            input.value = 'Esther';
            input.dispatchEvent(new Event('change'));
            await paint();
            assert.equal(normalizeText(greeting.textContent), 'Hi Esther', 'Should update if first name changes');
          });

          it('should not update name if last name changes', async function () {
            const configurator = document.querySelector('greeting-configurator');
            const last = configurator.querySelector('.last');
            const input = last.querySelector('input');
            const helloWorld = configurator.querySelector('hello-world');
            const greeting = helloWorld.querySelector('p');
            input.value = 'Brunner';
            input.dispatchEvent(new Event('change'));
            await paint();
            assert.equal(normalizeText(greeting.textContent), 'Hi Esther', 'Should not update if last name changes');
          });

          it('should update greeting if use fullname is checked or unchecked', async function () {
            const configurator = document.querySelector('greeting-configurator');
            const fullname = configurator.querySelector('input-checkbox');
            const input = fullname.querySelector('input');
            const helloWorld = configurator.querySelector('hello-world');
            const greeting = helloWorld.querySelector('p');
            input.checked = true;
            input.dispatchEvent(new Event('change'));
            await paint();
            assert.equal(normalizeText(greeting.textContent), 'Hi Esther Brunner', 'Should update if use fullname is checked');
            input.checked = false;
            input.dispatchEvent(new Event('change'));
            await paint();
            assert.equal(normalizeText(greeting.textContent), 'Hi Esther', 'Should update if use fullname is unchecked');
          });

        });

      });
    });
  </script>
</body>
</html>