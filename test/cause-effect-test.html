<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cause & Effect Test</title>
</head>
<body>
  <script type="module">
    import { runTests } from '@web/test-runner-mocha';
    import { assert } from '@esm-bundle/chai';
    import { state, computed, effect } from '../index.js';

    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
    const paint = () => new Promise(requestAnimationFrame);

    runTests(() => {

      describe('Cause', function () {

        describe('Empty cause', function () {

          it('should be undefined by default', function () {
            const cause = state();
            assert.isUndefined(cause.get(), 'no initial value for state defined');
          });

        });

        describe('Boolean cause', function () {

          it('should be boolean', function () {
            const cause = state(false);
            assert.isBoolean(cause.get(), 'should be boolean');
          });

          it('should set initial value to false', function () {
            const cause = state(false);
            assert.isFalse(cause.get(), 'should have initial value false');
          });

          it('should set initial value to true', function () {
            const cause = state(true);
            assert.isTrue(cause.get(), 'should have initial value true');
          });

          it('should set new value with .set(true)', function () {
            const cause = state(false);
            cause.set(true);
            assert.isTrue(cause.get(), 'should be true with any initial value');
          });

          it('should toggle initial value with .set(v => !v)', function () {
            const cause = state(false);
            cause.set(v => !v);
            assert.isTrue(cause.get(), 'should be true with initial value false');
          });

        });

        describe('Number cause', function () {

          it('should be number', function () {
            const cause = state(0);
            assert.isNumber(cause.get(), 'should be number');
          });

          it('should set initial value to 0', function () {
            const cause = state(0);
            assert.equal(cause.get(), 0, 'should have initial value 0');
          });

          it('should set new value with .set(42)', function () {
            const cause = state(0);
            cause.set(42);
            assert.equal(cause.get(), 42, 'should be 42 with any initial value');
          });

          it('should increment value with .set(v => ++v)', function () {
            const cause = state(0);
            cause.set(v => ++v);
            assert.equal(cause.get(), 1, 'should be 1 with initial value 0');
          });

        });

        describe('String cause', function () {

          it('should be string', function () {
            const cause = state('foo');
            assert.isString(cause.get(), 'should be string');
          });

          it('should set initial value to "foo"', function () {
            const cause = state('foo');
            assert.equal(cause.get(), 'foo', 'should have initial value "foo"');
          });

          it('should set new value with .set("bar")', function () {
            const cause = state('foo');
            cause.set('bar');
            assert.equal(cause.get(), 'bar', 'should be "bar" with any initial value');
          });

          it('should upper case value with .set(v => v.toUpperCase())', function () {
            const cause = state('foo');
            cause.set(v => v.toUpperCase());
            assert.equal(cause.get(), "FOO", 'should be "FOO" with initial value "foo"');
          });

        });

        describe('Function cause', function () {

          it('should be a function', function () {
            const x = 42;
            const cause = state(() => x * 2);
            assert.isFunction(cause.get(), 'should be function');
          });

          it('should be result of function', function () {
            const x = 42;
            const cause = state(() => x * 2);
            assert.equal(cause.get().call(), 84, 'should be 84 with initial value () => x * 2 and x = 42');
          });

          it('should be result of async function after promise is resolved', async function () {
            const x = 42;
            const cause = state(() => {
				new Promise(resolve => setTimeout(() => resolve(cause.set(x * 2)), 100));
            	return;
		  	});
            assert.isUndefined(cause.get().call(), 'should be undefined while promise is pending with promise resolver () => x * 2 and x = 42');
            await wait(100);
            assert.equal(cause.get(), 84, 'should be 84 after a delay with resolved promise for () => x * 2 and x = 42');
          });

          it('should set error state in async function after promise is rejected', async function () {
            const x = 42;
            const error = state();
            const cause = state(() => {
				new Promise((resolve, reject) => setTimeout(() => reject('error occurred')), 100).catch(reason => error.set(reason));
              	return;
		  	});
            assert.isUndefined(cause.get().call(), 'should be undefined while promise is pending');
            await wait(100);
            assert.equal(error.get(), 'error occurred', 'should set error message after a delay with rejected promise');
          });

          it('should be result of function dependent on another signal', function () {
            const x = state(42);
            const cause = state(() => x.get() * 2);
            assert.equal(cause.get().call(), 84, 'should be 84 with initial value () => x * 2 and x() = 42');
          });

          it('should be result of function dependent on a signal changed after declaration', function () {
            const x = state(42);
            const cause = state(() => x.get() * 2);
            x.set(24);
            assert.equal(cause.get().call(), 48, 'should be 48 with initial value () => x * 2 and x() = 24');
          });

          it('should set new value with .set(() => x / 2)', function () {
            const x = 42;
            const cause = state(() => x * 2);
            cause.set(() => x / 2);
            assert.equal(cause.get().call(), 21, 'should be 21 with any initial value and x = 21');
          });

          it('should upper case value with v => v.toUpperCase()', function () {
            const x = 'foo';
            const cause = state(() => x + 'bar');
            cause.set(v => () => v().toUpperCase());
            assert.equal(cause.get().call(), 'FOOBAR', 'should be "FOOBAR" with initial value () => x + "bar" and x = "foo"');
          });

        });

        describe('Array cause', function () {

          it('should be array', function () {
            const cause = state([1, 2, 3]);
            assert.isArray(cause.get(), 'should be array');
          });

          it('should set initial value to [1, 2, 3]', function () {
            const cause = state([1, 2, 3]);
            assert.deepEqual(cause.get(), [1, 2, 3], 'should be [1, 2, 3] with initial value [1, 2, 3]');
          });

          it('should set new value with .set([4, 5, 6])', function () {
            const cause = state([1, 2, 3]);
            cause.set([4, 5, 6]);
            assert.deepEqual(cause.get(), [4, 5, 6], 'should be [4, 5, 6] with any inital value');
          });

          it('should reflect current value of array after modification', function () {
            const array = [1, 2, 3];
            const cause = state(array);
            array.push(4); // don't do this! the result will be correct, but we can't trigger effects
            assert.deepEqual(cause.get(), [1, 2, 3, 4], 'should be [1, 2, 3, 4] with initial value [1, 2, 3]');
          });

          it('should set new value with .set([...array, 4])', function () {
            const array = [1, 2, 3];
            const cause = state(array);
            cause.set([...array, 4]); // use destructuring instead!
            assert.deepEqual(cause.get(), [1, 2, 3, 4], 'should be [1, 2, 3, 4] with initial value [1, 2, 3]');
          });

        });

        describe('Object cause', function () {

          it('should be object', function () {
            const cause = state({ a: 'a', b: 1 });
            assert.isObject(cause.get(), 'should be object');
          });

          it('should set initial value to { a: "a", b: 1 }', function () {
            const cause = state({ a: 'a', b: 1 });
            assert.deepEqual(cause.get(), { a: 'a', b: 1 }, 'should be { a: "a", b: 1 } with initial value { a: "a", b: 1 }');
          });

          it('should set new value with .set({ c: true })', function () {
            const cause = state({ a: 'a', b: 1 });
            cause.set({ c: true });
            assert.deepEqual(cause.get(), { c: true }, 'should be { c: true } with any inital value');
          });

          it('should reflect current value of object after modification', function () {
            const obj = { a: 'a', b: 1 };
            const cause = state(obj);
            obj.c = true; // don't do this! the result will be correct, but we can't trigger effects
            assert.deepEqual(cause.get(), { a: 'a', b: 1, c: true }, 'should be { a: "a", b: 1, c: true } with initial value { a: "a", b: 1 }');
          });

          it('should set new value with .set({...obj, c: true})', function () {
            const obj = { a: 'a', b: 1 };
            const cause = state(obj);
            cause.set({...obj, c: true}); // use destructuring instead!
            assert.deepEqual(cause.get(), { a: 'a', b: 1, c: true }, 'should be { a: "a", b: 1, c: true } with initial value { a: "a", b: 1 }');
          });

        });

      });

      describe('Derive', function () {

        it('should compute a function', function() {
          const derived = computed(() => 1 + 2);
          assert.equal(derived.get(), 3);
        });

        it('should compute function dependent on a signal', function() {
          const cause = state(42);
          const derived = computed(() => 1 + cause.get());
          assert.equal(derived.get(), 43);
        });

        /* it('should be added to state.effects', function () {
          const cause = state();
          const derived = computed(() => 1 + state());
          effect(() => computed());
          assert.equal(state.effects.size, 1);
          const derived2 = computed(() => 2 + state());
          effect(() => computed2());
          assert.equal(state.effects.size, 2);
          effect(() => computed() + computed2());
          assert.equal(state.effects.size, 2);
        }); */

        it('should compute function dependent on an updated signal', function() {
          const cause = state(42);
          const derived = computed(() => 1 + cause.get());
          cause.set(24);
          assert.equal(derived.get(), 25);
        });

        it('should compute function dependent on an async signal', async function() {
			const status = state('unset');
			const cause = state(() => {
				new Promise(resolve => {
					status.set('pending');
					setTimeout(() => resolve(cause.set(42)), 100);
				}).then(() => status.set('success'));
				return undefined;
			});
			const derived = computed(() => {
				const value = cause.get()
				return typeof value === 'function' ? value.call() : value + 1
			});
			assert.isUndefined(derived.get(), 'should be undefined while pending');
			assert.equal(status.get(), 'pending');
			await wait(100);
			assert.equal(derived.get(), 43, 'should be 43 after promise is resolved');
			assert.equal(status.get(), 'success');
        });

        it('should handle errors from an async signal gracefully', async function() {
			const status = state('unset');
			const error = state();
			const cause = state(() => {
				new Promise((resolve, reject) => {
					status.set('pending');
					setTimeout(() => reject('error occurred'), 100);
				}).catch(reason => {
					status.set('error');
					error.set(reason);
				});
				return undefined;
			});
			const derived = computed(() => {
				const value = cause.get()
				return typeof value === 'function' ? value.call() : value + 1
			});
			assert.isUndefined(derived.get(), 'should be undefined while pending');
			assert.equal(status.get(), 'pending');
			await wait(100);
			assert.equal(error.get(), 'error occurred', 'should set error message after promise is rejected');
			assert.equal(status.get(), 'error');
        });

        it('should compute function dependent on a chain of computed states dependent on a signal', function() {
          const cause = state(42);
          const derived1 = computed(() => 1 + cause.get());
          const derived2 = computed(() => derived1.get() * 2);
          const derived3 = computed(() => derived2.get() + 1);
          assert.equal(derived3.get(), 87);
        });

        it('should compute function dependent on a chain of computed states dependent on an updated signal', function() {
          const cause = state(42);
          const derived1 = computed(() => 1 + cause.get());
          const derived2 = computed(() => derived1.get() * 2);
          const derived3 = computed(() => derived2.get() + 1);
          cause.set(24);
          assert.equal(derived3.get(), 51);
        });

        it('should drop X->B->X updates', function () {
          let count = 0;
          const x = state(2);
          const a = computed(() => x.get() - 1);
          const b = computed(() => x.get() + a.get());
          const c = computed(() => {
            count++;
            return 'c: ' + b.get();
          });
          assert.equal(c.get(), 'c: 3');
          assert.equal(count, 1);
          x.set(4);
          assert.equal(c.get(), 'c: 7');
          assert.equal(count, 2);
        });

        it('should only update every signal once (diamond graph)', function() {
          let count = 0;
          const x = state('a');
          const a = computed(() => x.get());
          const b = computed(() => x.get());
          const c = computed(() => {
            count++;
            return a.get() + ' ' + b.get();
          });
          assert.equal(c.get(), 'a a');
          assert.equal(count, 1);
          x.set('aa');
          assert.equal(c.get(), 'aa aa');
          assert.equal(count, 2);
        });

        it('should only update every signal once (diamond graph + tail)', function() {
          let count = 0;
          const x = state('a');
          const a = computed(() => x.get());
          const b = computed(() => x.get());
          const c = computed(() => a.get() + ' ' + b.get());
          const d = computed(() => {
            count++;
            return c.get();
          });
          assert.equal(d.get(), 'a a');
          assert.equal(count, 1);
          x.set('aa');
          assert.equal(d.get(), 'aa aa');
          assert.equal(count, 2);
        });

        it('should bail out if result is the same', function() {
			let count = 0
			const x = state('a')
			const a = computed(() => {
				x.get()
				return 'foo'
			})
			const b = computed(() => {
				count++;
				return a.get()
			}, true) // turn memoization on
			assert.equal(b.get(), 'foo')
			assert.equal(count, 1)
			x.set('aa')
			assert.equal(b.get(), 'foo')
			assert.equal(count, 1)
        })

		it('should block if result remains unchanged', function() {
			let count = 0
			const x = state(42)
			const a = computed(() => x.get() % 2)
			const b = computed(() => a.get() ? 'odd' : 'even', true)
			const c = computed(() => {
				count++
				return `c: ${b.get()}`
			}, true)
			assert.equal(c.get(), 'c: even')
			assert.equal(count, 1)
			x.set(44)
			assert.equal(c.get(), 'c: even')
			assert.equal(count, 1)
		})

		it('should block if an error occurred', function() {
			let count = 0
			const x = state(0)
			const a = computed(() => {
				if (x.get() === 1) throw new Error('Calculation error')
				return 1
			}, true)
			const b = computed(() => a.get() ? 'success' : 'pending')
			const c = computed(() => {
				count++
				return `c: ${b.get()}`
			}, true)
			assert.equal(a.get(), 1)
			assert.equal(c.get(), 'c: success')
			assert.equal(count, 1)
			x.set(1)
			try {
				assert.equal(a.get(), 1)
			} catch (error) {
				assert.fail(`Error during reactive computation ${error.message}`);
            } finally {
				assert.equal(c.get(), 'c: success')
				assert.equal(count, 1)
			}
		})

      });

      describe('Effect', function () {

        /* it('should be added to state.effects', function () {
          const cause = state();
          effect(() => state());
          assert.equal(state.effects.size, 1);
          effect(() => state());
          assert.equal(state.effects.size, 2);
        });

        it('should be added to to computed.effects', function () {
          const cause = state();
          const derived = computed(() => 1 + state());
          effect(() => computed());
          assert.equal(computed.effects.size, 1);
          const derived2 = computed(() => 2 + state());
          effect(() => computed() + computed2());
          assert.equal(computed.effects.size, 2);
          assert.equal(computed2.effects.size, 1);
        }); */

        it('should be triggered after a state change', function() {
          const cause = state('foo');
          let effectDidRun = false;
          effect(() => {
            cause.get();
            effectDidRun = true;
            return;
          });
          cause.set('bar');
          assert.isTrue(effectDidRun);
        });

        it('should be triggered repeatedly after repeated state change', async function() {
          const cause = state(0);
          let count = 0;
          effect(() => {
            cause.get();
            count++;
          });
          for (let i = 0; i < 10; i++) {
            cause.set(i);
            await paint();
            assert.equal(count, i + 1); // + initial effect execution
          }
        });

      });

      describe('Batch', function () {

        it('should be triggered only once after repeated state change', async function() {
          const cause = state(0);
          let result = 0;
          let count = 0;
          effect(enqueue => {
            result = cause.get()
            enqueue(document.documentElement, 'count', () => () => count++)
          });
          (() => {
            for (let i = 1; i <= 10; i++) {
              cause.set(i);
            }
          })();
          await paint();
          assert.equal(result, 10);
          assert.equal(count, 1);
        });

      });

    });
  </script>
</body>
</html>