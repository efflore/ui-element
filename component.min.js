let t;const e=(t,e)=>typeof e===t,s=t=>e("function",t),n=t=>s(t)&&s(t.set),o=e=>{const o=()=>(t&&o.effects.add(t),e);return o.effects=new Set,o.set=t=>{const r=e;e=s(t)&&!n(t)?t(r):t,!Object.is(e,r)&&(t=>{for(const e of t)e.run()})(o.effects)},o},r=e=>{const n=new Map,o=()=>{const r=t;t=o;const c=e(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t)?.add(e)}));for(const t of n.values())for(const e of t)e();t=r,s(c)&&queueMicrotask(c)};o.run=()=>o(),o.targets=n,o()},c="context-request";class a extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(c,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const i=(t,e)=>Array.isArray(t)?t:[e,s(t)?t:t=>t],l=t=>e("string",t);class d extends HTMLElement{static consumedContexts;static providedContexts;static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,e,n){if(n===e)return;const[o,r]=i(this.attributeMap[t],t);this.set(o,s(r)?r(n,this,e):n)}connectedCallback(){const t=this.constructor,e=t.consumedContexts||[];for(const t of e)l(t)&&this.set(t,void 0);setTimeout((()=>{for(const t of e)l(t)&&this.dispatchEvent(new a(t,(e=>{const[n,o]=i(this.contextMap[t],t);this.set(n||t,s(o)?o(e,this):e)})))}));const n=t.providedContexts||[];n.length&&this.addEventListener(c,(t=>{const{context:e,callback:o}=t;l(e)&&n.includes(e)&&s(o)&&(t.stopPropagation(),o(this.#t.get(e)))}))}has(t){return this.#t.has(t)}get(t){const e=t=>s(t)?e(t()):t;return e(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){const o=this.#t.get(t);s&&n(o)&&o.set(e)}else this.#t.set(t,n(e)?e:o(e))}delete(t){return this.#t.delete(t)}async pass(t,e,n=customElements){await n.whenDefined(t.localName);for(const[n,r]of Object.entries(e))t.set(n,o(s(r)?r:this.#t.get(r)))}targets(t){const e=new Set,s=this.#t.get(t);if(!s||!s.effects)return e;for(const t of s.effects){const s=t.targets?.keys();if(s)for(const t of s)e.add(t)}return e}}const u=t=>!e("undefined",t)&&null!==t,f=(t,e=t)=>{const s=t.shadowRoot||t,n=(s,n,o)=>{e&&(t.set(s,n,!1),r((n=>t.has(s)&&n(e,o))))},o=()=>e;return o.first=e=>{const n=s.querySelector(e);return n&&f(t,n)},o.all=e=>Array.from(s.querySelectorAll(e)).map((e=>f(t,e))),o.on=(t,s)=>(e&&e.addEventListener(t,s),o),o.off=(t,s)=>(e&&e.removeEventListener(t,s),o),o.setText=t=>{e&&(Array.from(e.childNodes).filter((t=>t.nodeType!==Node.COMMENT_NODE)).forEach((t=>t.remove())),e.append(document.createTextNode(t)))},o.text=s=>{const r=e?.textContent||"";return n(s,r,(()=>{const e=t.get(s);o.setText(u(e)?String(e):r)})),o},o.prop=(s,r=s)=>(n(r,e[s],(()=>o[s]=t.get(r))),o),o.attr=(s,r=s)=>(n(r,e.getAttribute(s),(()=>{const n=t.get(r);u(n)?e.setAttribute(s,String(n)):e.removeAttribute(s)})),o),o.bool=(s,r=s)=>(n(r,e.hasAttribute(s),(()=>e.toggleAttribute(s,!!t.get(r)))),o),o.class=(s,r=s)=>(n(r,e.classList.contains(s),(()=>e.classList.toggle(s,!!t.get(r)))),o),o.style=(s,r=s)=>((t=>{for(const e of[HTMLElement,SVGElement,MathMLElement])if(t instanceof e)return!0;return!1})(e)?n(r,e.style.getPropertyValue(s),(()=>e.style.setProperty(s,String(t.get(r))))):console.warn("Cannot sync style property",s,"on non-stylable element"),o),o},h=t=>Number.isFinite(t)?t:void 0,p=t=>l(t),b=t=>h(parseInt(t,10)),g=t=>h(parseFloat(t)),x=t=>u(t)?t:void 0,m=t=>{let e;try{e=JSON.parse(t)}catch(t){console.error(t),e=void 0}return e},y=t=>{return u(s=t)&&e("object",s)?Object.keys(t):[];var s},v=(t,e={},s,n,o=d)=>{const r=class extends o{static observedAttributes=y(e.attributeMap);static providedContexts=e.providedContexts||[];static consumedContexts=y(e.contextMap).map((t=>({__context__:t})));attributeMap=e.attributeMap||{};contextMap=e.contextMap||{};connectedCallback(){super.connectedCallback(),s&&s(this,f(this))}disconnectedCallback(){super.disconnectedCallback(),n&&n(this)}};return r.define(t),r};export{p as asBoolean,b as asInteger,m as asJSON,g as asNumber,x as asString,v as component,d as default,r as effect,f as ui};