let t;const e=t=>"function"==typeof t,s=t=>e(t)&&e(t.set),n=n=>{const o=()=>(t&&o.effects.add(t),n);return o.effects=new Set,o.set=t=>{const r=n;n=e(t)&&!s(t)?t(r):t,!Object.is(n,r)&&(t=>{for(const e of t)e.run()})(o.effects)},o},o=s=>{const n=new Map,o=()=>{const r=t;t=o;const c=s(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t).add(e)}));for(const t of n.values())for(const e of t)e();t=r,e(c)&&queueMicrotask(c)};o.run=()=>o(),o.targets=n,o()},r="context-request";class c extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(r,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const a=(t,s)=>Array.isArray(t)?t:[s,e(t)?t:t=>t];class i extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,s,n){if(n!==s){const o=this.attributeMap[t],[r,c]=a(o,t);this.set(r,e(c)?c(n,this,s):n)}}connectedCallback(){const t=Object.getPrototypeOf(this),s=t.providedContexts||[];s.length&&this.addEventListener(r,(t=>{const{context:n,callback:o}=t;s.includes(n)&&e(o)&&(t.stopPropagation(),o(this.#t.get(n)))})),setTimeout((()=>{t.consumedContexts?.forEach((t=>{const s=new c(t,(s=>{const n=this.contextMap[t],[o,r]=a(n,t);this.#t.set(o||t,e(r)?r(s,this):s)}));this.dispatchEvent(s)}))}))}has(t){return this.#t.has(t)}get(t){const s=t=>e(t)?s(t()):t;return s(this.#t.get(t))}set(t,e,o=!0){if(this.#t.has(t)){const n=this.#t.get(t);o&&s(n)&&n.set(e)}else{const o=s(e)?e:n(e);this.#t.set(t,o)}}delete(t){return this.#t.delete(t)}async pass(t,s,o=customElements){await o.whenDefined(t.localName);for(const[o,r]of Object.entries(s))t.set(o,n(e(r)?r:this.#t.get(r)))}targets(t){const e=new Set;for(const s of this.#t.get(t).effects)for(const t of s.targets.keys())e.add(t);return e}}const l=t=>Number.isFinite(t)&&t,u=t=>"string"==typeof t,f=t=>l(parseInt(t,10)),d=t=>l(parseFloat(t)),h=t=>t,b=t=>JSON.parse(t),p=t=>void 0!==t,g=(t,e=t)=>{const s=t.shadowRoot||t,n=(s,n,r)=>{e&&(t.set(s,n,!1),o((n=>t.has(s)&&n(e,r))))},r=()=>e;return r.first=e=>{const n=s.querySelector(e);return n&&g(t,n)},r.all=e=>Array.from(s.querySelectorAll(e)).map((e=>g(t,e))),r.on=(t,s)=>(e&&e.addEventListener(t,s),r),r.off=(t,s)=>(e&&e.removeEventListener(t,s),r),r.setText=t=>{e&&(Array.from(e.childNodes).filter((t=>t.nodeType!==Node.COMMENT_NODE)).forEach((t=>t.remove())),e.append(document.createTextNode(t)))},r.text=s=>{const o=e?.textContent||"";return n(s,o,(()=>{const e=t.get(s);r.setText(p(e)?String(e):o)})),r},r.prop=(s,o=s)=>(n(o,e[s],(()=>r[s]=t.get(o))),r),r.attr=(s,o=s)=>(n(o,e.getAttribute(s),(()=>{const n=t.get(o);p(n)?e.setAttribute(s,String(n)):e.removeAttribute(s)})),r),r.bool=(s,o=s)=>(n(o,e.hasAttribute(s),(()=>e.toggleAttribute(s,!!t.get(o)))),r),r.class=(s,o=s)=>(n(o,e.classList.contains(s),(()=>e.classList.toggle(s,!!t.get(o)))),r),r.style=(s,o=s)=>((t=>{for(const e of[HTMLElement,SVGElement,MathMLElement])if(t instanceof e)return!0;return!1})(e)?n(o,e.style.getPropertyValue(s),(()=>e.style.setProperty(s,String(t.get(o))))):console.warn("Cannot sync style property",s,"on non-stylable element"),r),r},y=(t,e={},s,n)=>{const o=class extends i{static observedAttributes=Object.keys(e);attributeMap=e;connectedCallback(){super.connectedCallback(),s&&s(this,g(this))}disconnectedCallback(){n&&n(this)}};return o.define(t),o};export{u as asBoolean,f as asInteger,b as asJSON,d as asNumber,h as asString,y as component,i as default,o as effect,g as ui};