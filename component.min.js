const t=t=>e=>typeof e===t,e=t=>null!=t,s=t("string"),n=t("function");let o;const r=t=>n(t)&&n(t.set),c=t=>{const e=()=>(o&&e.effects.add(o),t);return e.effects=new Set,e.set=s=>{const o=t;t=n(s)&&!r(s)?s(o):s,!Object.is(t,o)&&(t=>{for(const e of t)e.run()})(e.effects)},e},a=t=>{const e=new Map,s=()=>{const r=o;o=s;const c=t(((t,s)=>{!e.has(t)&&e.set(t,new Set),e.get(t)?.add(s)}));for(const t of e.values())for(const e of t)e();o=r,n(c)&&queueMicrotask(c)};s.run=()=>s(),s.targets=e,s()},i="context-request";class l extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(i,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class u extends HTMLElement{static consumedContexts;static providedContexts;static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(t,e,s){if(s===e)return;const o=this.attributeMap[t];this.set(t,n(o)?o(s,this,e):s)}connectedCallback(){const t=this.constructor,e=t.consumedContexts||[];for(const t of e)this.set(String(t),void 0);setTimeout((()=>{for(const t of e)this.dispatchEvent(new l(t,(e=>this.set(String(t),e))))}));const s=t.providedContexts||[];s.length&&this.addEventListener(i,(t=>{const{context:e,callback:o}=t;s.includes(e)&&n(o)&&(t.stopPropagation(),o(this.#t.get(String(e))))}))}has(t){return this.#t.has(t)}get(t){const e=t=>n(t)?e(t()):t;return e(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){const n=this.#t.get(t);s&&r(n)&&n.set(e)}else this.#t.set(t,r(e)?e:c(e))}delete(t){return this.#t.delete(t)}async pass(t,e,s=customElements){await s.whenDefined(t.localName);for(const[s,o]of Object.entries(e))t.set(s,c(n(o)?o:this.#t.get(o)))}targets(t){const e=new Set,s=this.#t.get(t);if(!s||!s.effects)return e;for(const t of s.effects){const s=t.targets?.keys();if(s)for(const t of s)e.add(t)}return e}}const d=t=>Number.isFinite(t)?t:void 0,f=s,h=t=>d(parseInt(t,10)),b=t=>d(parseFloat(t)),p=t=>e(t)?t:void 0,g=t=>{let e;try{e=JSON.parse(t)}catch(t){console.error(t),e=void 0}return e},m=(t,s=t)=>{const n=t.shadowRoot||t,o=(e,n,o)=>{s&&(t.set(e,n,!1),a((n=>t.has(e)&&n(s,o))))},r=()=>s;return r.first=e=>{const s=n.querySelector(e);return s&&m(t,s)},r.all=e=>Array.from(n.querySelectorAll(e)).map((e=>m(t,e))),r.on=(t,e)=>(s&&s.addEventListener(t,e),r),r.off=(t,e)=>(s&&s.removeEventListener(t,e),r),r.setText=t=>{s&&(Array.from(s.childNodes).filter((t=>t.nodeType!==Node.COMMENT_NODE)).forEach((t=>t.remove())),s.append(document.createTextNode(t)))},r.text=n=>{const c=s?.textContent||"";return o(n,c,(()=>{const s=t.get(n);r.setText(e(s)?String(s):c)})),r},r.prop=(e,n=e)=>(o(n,s[e],(()=>r[e]=t.get(n))),r),r.attr=(n,c=n)=>(o(c,s.getAttribute(n),(()=>{const o=t.get(c);e(o)?s.setAttribute(n,String(o)):s.removeAttribute(n)})),r),r.bool=(e,n=e)=>(o(n,s.hasAttribute(e),(()=>s.toggleAttribute(e,!!t.get(n)))),r),r.class=(e,n=e)=>(o(n,s.classList.contains(e),(()=>s.classList.toggle(e,!!t.get(n)))),r),r.style=(e,n=e)=>((t=>{for(const e of[HTMLElement,SVGElement,MathMLElement])if(t instanceof e)return!0;return!1})(s)?o(n,s.style.getPropertyValue(e),(()=>s.style.setProperty(e,String(t.get(n))))):console.warn("Cannot sync style property",e,"on non-stylable element"),r),r},x=(t,s={},n,o,r=u)=>{const c=class extends r{static observedAttributes=(t=>e(t)&&"object"==typeof t)(s.attributeMap)?Object.keys(s.attributeMap):[];static providedContexts=s.providedContexts||[];static consumedContexts=s.consumedContexts||[];attributeMap=s.attributeMap||{};connectedCallback(){super.connectedCallback(),n&&n(this,m(this))}disconnectedCallback(){super.disconnectedCallback(),o&&o(this)}};return c.define(t),c};export{f as asBoolean,h as asInteger,g as asJSON,b as asNumber,p as asString,x as component,u as default,a as effect,m as ui};