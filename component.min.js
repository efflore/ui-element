const t=t=>e=>typeof e===t,e=t=>null!=t,s=t("string"),n=t("object"),o=t("function"),r=t=>t.nodeType!==Node.COMMENT_NODE,a="nothing",c=t=>o(t)?c(t()):t,i=t=>o(t)&&"type"in t,l=(t,e)=>i(e)&&e.type===t,u=t=>(t=>(t=>null==t)(t)||l(a,t))(t)?f():d(t),d=t=>{const e=()=>t;return e.type=typeof t,e.or=e=>t,e.map=e=>u(e(t)),e.chain=e=>e(t),e.filter=e=>e(t)?d(t):f(),e},f=()=>new Proxy((()=>{}),{get:(t,e)=>{switch(e){case"type":return a;case"toString":return()=>"";case"or":return t=>t;case"chain":return t=>t();default:return()=>f()}}}),h="state";let p;const b=t=>l(h,t),g=t=>b(t)||(t=>l("computed",t))(t),m=t=>{const e=()=>(p&&e.effects.add(p),t);return e.type=h,e.effects=new Set,e.set=s=>{const n=t;t=o(s)&&!i(s)?(t=>i(t)&&"map"in t)(t)?t.map(s):s(t):s,!Object.is(c(t),c(n))&&(t=>{for(const e of t)e.run()})(e.effects)},e},y=t=>{const e=new Map,s=()=>{const n=p;p=s;const r=t(((t,s)=>{!e.has(t)&&e.set(t,new Set),e.get(t)?.add(s)}));for(const t of e.values()){for(const e of t)e();t.clear()}p=n,o(r)&&queueMicrotask(r)};s.type="effect",s.run=()=>s(),s.targets=e,s()},x="context-request";class v extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(x,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class C extends HTMLElement{static consumedContexts;static providedContexts;static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(t,e,s){if(s===e)return;const n=this.attributeMap[t],r=u(s);this.set(t,o(n)?r.map((t=>n(t,this,e))):r)}connectedCallback(){const t=this.constructor,e=t.consumedContexts||[];for(const t of e)this.set(String(t),void 0);setTimeout((()=>{for(const t of e)this.dispatchEvent(new v(t,(e=>this.set(String(t),e))))}));const s=t.providedContexts||[];s.length&&this.addEventListener(x,(t=>{const{context:e,callback:n}=t;s.includes(e)&&o(n)&&(t.stopPropagation(),n(this.#t.get(String(e))))}))}has(t){return this.#t.has(t)}get(t){return c(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){if(s){const s=this.#t.get(t);b(s)&&s.set(e)}}else this.#t.set(t,g(e)?e:m(e))}delete(t){return this.#t.delete(t)}async pass(t,e,s=customElements){await s.whenDefined(t.localName);for(const[s,n]of Object.entries(e))t.set(s,g(n)?n:o(n)?m(n):this.#t.get(n))}targets(t){const e=new Set,s=this.#t.get(t);if(!s||!s.effects)return e;for(const t of s.effects){const s=t.targets?.keys();if(s)for(const t of s)e.add(t)}return e}}const M=t=>Number.isFinite(t)?t:void 0,E=t=>s(t),S=t=>M(parseInt(t,10)),k=t=>M(parseFloat(t)),w=t=>e(t)?t:void 0,N=t=>{let e;try{e=JSON.parse(t)}catch(t){console.error(t),e=void 0}return e},A=t=>{const e=()=>t;return e.type="list",e.map=e=>A(t.map((t=>e(t)))),e.chain=e=>e(t),e.filter=e=>A(t.filter((t=>e(t)))),e},L=(t,s=t)=>{const n=()=>s;return n.type=s.localName,n.map=e=>L(t,e(t,s)),n.chain=e=>e(t,s),n.filter=e=>e(t,s)?L(t,s):f(),n.first=e=>{const s=(t.shadowRoot||t).querySelector(e);return s?L(t,s):f()},n.all=e=>A(Array.from((t.shadowRoot||t).querySelectorAll(e)).map((e=>L(t,e)))),n.on=(t,e)=>(s.addEventListener(t,e),n),n.off=(t,e)=>(s.removeEventListener(t,e),n),n.text=o=>{const a=s.textContent||"";return t.set(o,a,!1),y((n=>t.has(o)&&n(s,(()=>{const n=t.get(o);Array.from(s.childNodes).filter(r).forEach((t=>t.remove())),s.append(document.createTextNode(e(n)?String(n):a))})))),n},n.prop=(e,o=e)=>(t.set(o,s[e],!1),y((n=>t.has(o)&&n(s,(()=>s[e]=t.get(o))))),n),n.attr=(o,r=o)=>(t.set(r,s.getAttribute(o),!1),y((n=>t.has(r)&&n(s,(()=>{const n=t.get(r);e(n)?s.setAttribute(o,String(n)):s.removeAttribute(o)})))),n),n.bool=(e,o=e)=>(t.set(o,s.hasAttribute(e),!1),y((n=>t.has(o)&&n(s,(()=>s.toggleAttribute(e,!!t.get(o)))))),n),n.class=(e,o=e)=>(t.set(o,s.classList.contains(e),!1),y((n=>t.has(o)&&n(s,(()=>s.classList.toggle(e,!!t.get(o)))))),n),n.style=(e,o=e)=>((t=>{for(const e of[HTMLElement,SVGElement,MathMLElement])if(t instanceof e)return!0;return!1})(s)?(t.set(o,s.style[e],!1),y((n=>t.has(o)&&n(s,(()=>s.style[e]=t.get(o)))))):console.error(`Style effect not supported for element type ${s.localName}`),n),n},O=(t,s={},o,r,a=C)=>{const c=class extends a{static observedAttributes=(t=>e(t)&&n(t))(s.attributeMap)?Object.keys(s.attributeMap):[];static providedContexts=s.providedContexts||[];static consumedContexts=s.consumedContexts||[];attributeMap=s.attributeMap||{};connectedCallback(){super.connectedCallback(),o&&o(this,L(this))}disconnectedCallback(){super.disconnectedCallback(),r&&r(this)}};return c.define(t),c};export{E as asBoolean,S as asInteger,N as asJSON,k as asNumber,w as asString,O as component,C as default,y as effect,L as ui};