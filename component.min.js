const t=t=>"function"==typeof t,e=e=>t(e)&&t(e.set),s=t=>void 0!==t;let o;const c=s=>{const c=()=>(o&&c.effects.add(o),s);return c.effects=new Set,c.set=o=>{const n=s;if(s=t(o)&&!e(o)?o(n):o,!Object.is(s,n))for(const t of c.effects)t()},c},n=e=>{const s=new Map,c=()=>{const n=o;o=c;const a=e(((t,e)=>{!s.has(t)&&s.set(t,new Set),s.get(t).add(e)}));o=n,queueMicrotask((()=>{for(const t of s.values())for(const e of t)e();t(a)&&a()}))};c.targets=s,c()},a="context-request";class r extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(a,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class i extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(e,s,o){if(o!==s){const c=this.attributeMap[e],[n,a]=Array.isArray(c)?c:[e,c];this.set(n,t(a)?a(o,this,s):o)}}connectedCallback(){const e=Object.getPrototypeOf(this),s=e.providedContexts||[];s.length&&this.addEventListener(a,(e=>{const{context:o,callback:c}=e;s.includes(o)&&t(c)&&(e.stopPropagation(),c(this.#t.get(o)))})),setTimeout((()=>{e.consumedContexts?.forEach((e=>{const s=new r(e,(s=>{const o=this.contextMap[e],[c,n]=Array.isArray(o)?o:[e,o];this.#t.set(c||e,t(n)?n(s,this):s)}));this.dispatchEvent(s)}))}))}has(t){return this.#t.has(t)}get(e){const s=e=>t(e)?s(e()):e;return s(this.#t.get(e))}set(t,s,o=!0){if(this.#t.has(t)){const c=this.#t.get(t);o&&e(c)&&c.set(s)}else{const o=e(s)?s:c(s);this.#t.set(t,o)}}delete(t){return this.#t.delete(t)}async pass(e,s,o=customElements){await o.whenDefined(e.localName);for(const[o,n]of Object.entries(s))e.set(o,c(t(n)?n:this.#t.get(n)))}targets(t){const e=new Set;for(const s of this.#t.get(t).effects)for(const t of s.targets.keys())e.add(t);return e}}const l=t=>"string"==typeof t,f=t=>parseInt(t,10),u=t=>parseFloat(t),h=t=>t,d="text",g="prop",b="attr",p="class",m="style",y=t=>{const e=t.shadowRoot||t,o=()=>t;var c;return o.first=t=>{const s=e.querySelector(t);return s&&y(s)},o.all=t=>Array.from(e.querySelectorAll(t)).map((t=>y(t))),o[d]={get:()=>t.textContent?.trim()||"",set:e=>{Array.from(t.childNodes).filter((t=>t.nodeType!==Node.COMMENT_NODE)).forEach((t=>t.remove())),t.append(document.createTextNode(e))}},o[g]={get:e=>t[e],set:(e,s)=>t[e]=s},o[b]={get:e=>t.getAttribute(e),set:(e,o)=>"boolean"==typeof o?t.toggleAttribute(e,o):s(o)?t.setAttribute(e,o):t.removeAttribute(e)},o[p]={get:e=>t.classList.contains(e),set:(e,s)=>t.classList.toggle(e,s)},((c=t)instanceof HTMLElement||c instanceof SVGElement||c instanceof MathMLElement)&&(o[m]={get:e=>t.style.getPropertyValue(e),set:(e,o)=>s(o)?t.style.setProperty(e,o):t.style.removeProperty(e)}),o},E=(t,e,s)=>{const o=`data-${t.localName}-${e}`,c=t=>{s(t,t.getAttribute(o)),t.removeAttribute(o)};t.hasAttribute(o)&&c(t);for(const e of t.querySelectorAll(`[${o}]`))c(e)},v="hover",A="focus",x=(t,e={},o,c)=>{const a=class extends i{static observedAttributes=Object.keys(e);attributeMap=e;connectedCallback(){var t;super.connectedCallback(),o&&o(this),t=this,[d,g,b,p,m].forEach((e=>{E(t,e,e===d?(o,c)=>{const a=c.trim(),r=y(o)[e],i=r.get();t.set(a,i,!1),n((e=>{if(t.has(a)){const c=t.get(a);e(o,(()=>r.set(s(c)?c:i)))}}))}:(s,o)=>{const c=(t,e)=>t.split(e).map((t=>t.trim()));c(o,";").forEach((o=>{const[a,r=a]=c(o,":"),i=y(s)[e];t.set(r,i.get(),!1),n((e=>{if(t.has(r)){const o=t.get(r);e(s,(()=>i.set(a,o)))}}))}))})})),((t,e="ui-effect")=>{[v,A].forEach((s=>{const[o,c]=s===v?["mouseenter","mouseleave"]:["focus","blur"];E(t,s,((s,n)=>{const a=n.trim(),r=(o,c)=>s.addEventListener(o,(()=>{for(const s of t.targets(a))s.classList.toggle(e,c)}));r(o,!0),r(c,!1)}))}))})(this)}disconnectedCallback(){c&&c(this)}};return a.define(t),a};export{y as $,i as UIElement,l as asBoolean,f as asInteger,u as asNumber,h as asString,x as default,n as effect};