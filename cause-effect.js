const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),s=e=>n(e)?s(e()):e,o=(e,t)=>e&&n(e[t]),c=e=>(e=>(e=>null!=e)(e)&&(t(e)||n(e)))(e)&&o(e,"map"),f=Symbol(),r=Symbol(),u=Symbol();let a;const l=e=>{for(const t of e)t.run()},p=e=>n(e)&&o(e,"set"),y=e=>p(e)||(e=>n(e)&&o(e,"run")&&"effects"in e)(e),d=e=>{const t=()=>(a&&t.effects.add(a),e);return t.type=f,t.effects=new Set,t.set=o=>{const f=e;e=n(o)&&!y(o)?c(e)?e.map(o):o(e):o,Object.is(s(e),s(f))||l(t.effects)},t},S=(e,t=!1)=>{let n,s=!0;const o=()=>{if(a&&o.effects.add(a),t&&!s)return n;const c=a;return a=o,n=e(),s=!1,a=c,n};return o.type=r,o.effects=new Set,o.run=()=>{s=!0,t&&l(o.effects)},o},b=e=>{const t=new Map,s=()=>{const o=a;a=s;const c=e(((e,n)=>{t.has(e)||t.set(e,new Set),t.get(e)?.add(n)}));for(const e of t.values()){for(const t of e)t();e.clear()}a=o,n(c)&&queueMicrotask(c)};s.type=u,s.run=()=>s(),s.targets=t,s()};export{d as cause,S as derive,b as effect,y as isSignal,p as isState};
