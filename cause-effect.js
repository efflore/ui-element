const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),s=e=>(e=>null!=e)(e)&&(t(e)||n(e)),c=(e,t)=>n(e[t]);let f;const o=e=>{for(const t of e)t.run()},r=e=>s(e)&&c(e,"set"),u=e=>r(e)||(e=>s(e)&&c(e,"run")&&"effects"in e)(e),a=e=>{const t=()=>(f&&t.effects.add(f),e);return t.effects=new Set,t.set=s=>{const c=e;e=n(s)&&!u(s)?s(e):s,Object.is(e,c)||o(t.effects)},t},d=(e,t=!1)=>{let n,s=!0;const c=()=>{if(f&&c.effects.add(f),t&&!s)return n;const o=f;return f=c,n=e(),s=!1,f=o,n};return c.effects=new Set,c.run=()=>{s=!0,t&&o(c.effects)},c},l=e=>{const t=new Map,s=()=>{const c=f;f=s;const o=e(((e,n)=>{t.has(e)||t.set(e,new Set),t.get(e)?.add(n)}));for(const e of t.values()){for(const t of e)t();e.clear()}f=c,n(o)&&queueMicrotask(o)};s.run=()=>s(),s.targets=t,s()};export{a as cause,d as derive,l as effect,u as isSignal,r as isState};
