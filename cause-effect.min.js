const e=e=>n=>typeof n===e,n=e("object"),t=e("function"),c=e=>(e=>null!=e)(e)&&(n(e)||t(e)),o=(e,n)=>t(e[n]),s="warn",r="error";let f;const{enqueue:a,cleanup:u}=(()=>{const e=new Map,n=new Map;let t;const c=(e,n)=>{try{e()}catch(e){((e,n,t="debug")=>{[r,s].includes(t)&&console[t](n,e)})(e,n,r)}},o=()=>{t=null;for(const[n,t]of e)for(const[e,o]of t)c(o(n),` Effect ${e} on ${n?.localName||"unknown"} failed`);e.clear();for(const e of n.values())c(e,"Cleanup failed");n.clear()},f=e=>(n,c)=>{const s=!e.has(n);e.set(n,c),s&&(t&&cancelAnimationFrame(t),t=requestAnimationFrame(o))};return queueMicrotask(o),{enqueue:(n,t,c)=>{return f((o=n,e.has(o)||e.set(o,new Map),e.get(o)))(t,c);var o},cleanup:f(n)}})(),l=e=>{for(const n of e)n.run()},i=e=>c(e)&&o(e,"set"),d=e=>i(e)||(e=>c(e)&&o(e,"run")&&"effects"in e)(e),p=e=>{const n=()=>(f&&n.effects.add(f),e);return n.effects=new Set,n.set=c=>{const o=e;e=t(c)&&!d(c)?c(e):c,Object.is(e,o)||l(n.effects)},n},w=(e,n=!1)=>{let t,c=!0;const o=()=>{if(f&&o.effects.add(f),n&&!c)return t;const s=f;return f=o,t=e(),c=!1,f=s,t};return o.effects=new Set,o.run=()=>{c=!0,n&&l(o.effects)},o},m=e=>{const n=new Set,c=()=>{const o=f;f=c;const s=e(((e,t,c)=>{a(e,t,c),n.add(e)}));t(s)&&u(c,s),f=o};c.run=()=>c(),c.targets=n,c()};export{p as cause,w as derive,m as effect,d as isSignal,i as isState};
