const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),s=e=>n(e)?s(e()):e,c=(e,t)=>e&&n(e[t]),f=e=>(e=>(e=>null!=e)(e)&&(t(e)||n(e)))(e)&&c(e,"map");let o;const r=e=>{for(const t of e)t.run()},u=e=>n(e)&&c(e,"set"),a=e=>u(e)||(e=>n(e)&&c(e,"run")&&"effects"in e)(e),d=e=>{const t=()=>(o&&t.effects.add(o),e);return t.effects=new Set,t.set=c=>{const o=e;e=n(c)&&!a(c)?f(e)?e.map(c):c(e):c,!Object.is(s(e),s(o))&&r(t.effects)},t},l=(e,t=!1)=>{let n,s=!0;const c=()=>{if(o&&c.effects.add(o),t&&!s)return n;const f=o;return o=c,n=e(),s=!1,o=f,n};return c.effects=new Set,c.run=()=>{s=!0,t&&r(c.effects)},c},i=e=>{const t=new Map,s=()=>{const c=o;o=s;const f=e(((e,n)=>{!t.has(e)&&t.set(e,new Set),t.get(e)?.add(n)}));for(const e of t.values()){for(const t of e)t();e.clear()}o=c,n(f)&&queueMicrotask(f)};s.run=()=>s(),s.targets=t,s()};export{d as cause,l as derive,i as effect,a as isSignal,u as isState};