const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),c=e=>(e=>null!=e)(e)&&(t(e)||n(e)),o=(e,t)=>n(e[t]),s=e=>({map:()=>s(e),fold:t=>t(e),catch:t=>t(e)}),r=e=>{try{return t=e(),{map:e=>r((()=>e(t))),fold:(e,n)=>n(t),catch:()=>{}}}catch(e){return s(e)}var t},a="error",f=(e,t,n="debug")=>((e=>"warn"===e||e===a)(n)&&console[n](t,e),e);let u;const l=(()=>{const e=new Map,t=new Map;let n;const c=()=>{n&&cancelAnimationFrame(n),n=requestAnimationFrame(s)},o=(e,t)=>{r(e).catch((e=>f(e,t,a)))},s=()=>{n=null;let c="Couldn't apply effect ";const s="unknown element";for(const[t,n]of e)for(const[e,r]of n)o(r,c+`${e} on ${t?.localName||s}`);e.clear(),c="Couldn't clean up after effect for ";for(const[e,n]of t)o(n,c+(e?.localName||s));t.clear()};return queueMicrotask(s),{enqueue:(t,n,o)=>{e.has(t)||e.set(t,new Map);const s=e.get(t);s.has(n)||s.set(n,o),c()},cleanup:(e,n)=>{t.has(e)||t.set(e,n),c()},flush:s}})(),p=e=>{for(const t of e)t.run()},d=e=>c(e)&&o(e,"set"),h=e=>d(e)||(e=>c(e)&&o(e,"run")&&"effects"in e)(e),i=e=>{const t=()=>(u&&t.effects.add(u),e);return t.effects=new Set,t.set=c=>{const o=e;e=n(c)&&!h(c)?c(e):c,Object.is(e,o)||p(t.effects)},t},m=(e,t=!1)=>{let n,c=!0;const o=()=>{if(u&&o.effects.add(u),t&&!c)return n;const s=u;return u=o,n=e(),c=!1,u=s,n};return o.effects=new Set,o.run=()=>{c=!0,t&&p(o.effects)},o},w=e=>{const t=new Set,c=()=>{const o=u;let s;u=c;const r=e(((e,n,c)=>{l.enqueue(e,n,c),t.has(e)||t.add(e),s=e}));n(r)&&l.cleanup(s,r),u=o};c.run=()=>c(),c.targets=t,c()};export{i as cause,m as derive,w as effect,h as isSignal,d as isState};
