const t=(e="function",t=>typeof t===e);var e;const n=e=>t(e)?n(e()):e,s=e=>t(e)&&"type"in e,c=(t,e)=>s(e)&&e.type===t,o="state",f="computed";let r;const a=t=>{for(const e of t)e.run()},u=t=>c(o,t),p=t=>u(t)||(t=>c(f,t))(t),d=e=>{const c=()=>(r&&c.effects.add(r),e);return c.type=o,c.effects=new Set,c.set=o=>{const f=e;e=t(o)&&!s(o)?(t=>s(t)&&"map"in t)(e)?e.map(o):o(e):o,!Object.is(n(e),n(f))&&a(c.effects)},c},i=(t,e=!1)=>{let n,s=!0;const c=()=>{if(r&&c.effects.add(r),e&&!s)return n;const o=r;return r=c,n=t(),s=!1,r=o,n};return c.type=f,c.effects=new Set,c.run=()=>{s=!0,e&&a(c.effects)},c},y=e=>{const n=new Map,s=()=>{const c=r;r=s;const o=e(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t)?.add(e)}));for(const t of n.values()){for(const e of t)e();t.clear()}r=c,t(o)&&queueMicrotask(o)};s.type="effect",s.run=()=>s(),s.targets=n,s()};export{d as cause,i as derive,y as effect,p as isSignal,u as isState};