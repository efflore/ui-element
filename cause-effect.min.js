const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),c=e=>(e=>null!=e)(e)&&(t(e)||n(e)),o=(e,t)=>n(e[t]),s="error",r=(e,t,n="debug")=>((e=>"warn"===e||e===s)(n)&&console[n](t,e),e);let f;const{enqueue:a,cleanup:u}=(()=>{const e=new Map,t=new Map;let n;const c=(e,t)=>{try{e()}catch(e){r(e,t,s)}},o=()=>{n=null;for(const[t,n]of e)for(const[e,o]of n)c(o(t),` Effect ${e} on ${t?.localName||"unknown"} failed`);e.clear();for(const e of t.values())c(e,"Cleanup failed");t.clear()},f=e=>(t,c)=>{const s=!e.has(t);e.set(t,c),s&&(n&&cancelAnimationFrame(n),n=requestAnimationFrame(o))};return queueMicrotask(o),{enqueue:(t,n,c)=>{return f((o=t,e.has(o)||e.set(o,new Map),e.get(o)))(n,c);var o},cleanup:f(t)}})(),l=e=>{for(const t of e)t.run()},i=e=>c(e)&&o(e,"set"),d=e=>i(e)||(e=>c(e)&&o(e,"run")&&"effects"in e)(e),p=e=>{const t=()=>(f&&t.effects.add(f),e);return t.effects=new Set,t.set=c=>{const o=e;e=n(c)&&!d(c)?c(e):c,Object.is(e,o)||l(t.effects)},t},w=(e,t=!1)=>{let n,c=!0;const o=()=>{if(f&&o.effects.add(f),t&&!c)return n;const s=f;return f=o,n=e(),c=!1,f=s,n};return o.effects=new Set,o.run=()=>{c=!0,t&&l(o.effects)},o},m=e=>{const t=new Set,c=()=>{const o=f;f=c;const s=e(((e,n,c)=>{a(e,n,c),t.add(e)}));n(s)&&u(c,s),f=o};c.run=()=>c(),c.targets=t,c()};export{p as cause,w as derive,m as effect,d as isSignal,i as isState};
