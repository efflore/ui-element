let t;const e=t=>{for(const e of t)e.run()},s=(t,e)=>typeof e===t,n=t=>s("function",t),f=t=>n(t)&&n(t.set),o=s=>{const o=()=>(t&&o.effects.add(t),s);return o.effects=new Set,o.set=t=>{const c=s;s=n(t)&&!f(t)?t(c):t,!Object.is(s,c)&&e(o.effects)},o},c=(s,n=!1)=>{let f,o=!0;const c=()=>{if(t&&c.effects.add(t),n&&!o)return f;const e=t;return t=c,f=s(),o=!1,t=e,f};return c.effects=new Set,c.run=()=>{o=!0,n&&e(c.effects)},c},r=e=>{const s=new Map,f=()=>{const o=t;t=f;const c=e(((t,e)=>{!s.has(t)&&s.set(t,new Set),s.get(t)?.add(e)}));for(const t of s.values())for(const e of t)e();t=o,n(c)&&queueMicrotask(c)};f.run=()=>f(),f.targets=s,f()};export{o as cause,c as derive,r as effect,s as is,n as isFunction,f as isState};