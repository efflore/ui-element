const e=e=>n=>typeof n===e,n=e("object"),t=e("function"),c="warn",a="error",o=(e,n,t="debug")=>([a,c].includes(t)&&console[t](n,e),e),{enqueue:r,cleanup:s}=(()=>{const e=new Map,n=new Map;let t;const c=(e,n)=>{try{e()}catch(e){o(e,n,a)}},r=()=>{t=null,e.forEach(((e,n)=>e.forEach(((e,t)=>c(e(n),`Effect ${t} on ${n?.localName||"unknown"} failed`))))),e.clear(),n.forEach((e=>c(e,"Cleanup failed"))),n.clear()},s=e=>(n,c)=>{const a=!e.has(n);e.set(n,c),a&&(t&&cancelAnimationFrame(t),t=requestAnimationFrame(r))};return queueMicrotask(r),{enqueue:(n,t,c)=>{return s((a=n,e.has(a)||e.set(a,new Map),e.get(a)))(t,c);var a},cleanup:s(n)}})();let u;const l=e=>{u&&e.add(u)},i=e=>e.forEach((e=>e())),f=(e,n)=>{const t=u;u=n;try{e()}catch(e){o(e,"Error during reactive computation",a)}finally{u=t}},p=e=>(e=>(e=>null!=e)(e)&&(n(e)||t(e)))(e)&&t(e["set"]),h=e=>{const n=new Set,c=()=>(l(n),e);return c.set=c=>{const a=e;e=t(c)&&!p(c)?c(e):c,Object.is(e,a)||i(n)},c},d=(e,n=!1)=>{const t=new Set;let c,a=!0;return()=>(l(t),n&&!a||f((()=>{c=e(),a=!1}),(()=>{a=!0,n&&i(t)})),c)},w=e=>{const n=()=>f((()=>{const n=e(r);t(n)&&s(e,n)}),n);n()};export{h as cause,d as derive,w as effect,p as isState};
