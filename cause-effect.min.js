const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),c=e=>(e=>null!=e)(e)&&(t(e)||n(e)),s=(e,t)=>n(e[t]),o="error",r=(e,t,n="debug")=>((e=>"warn"===e||e===o)(n)&&console[n](t,e),e);let a;const{enqueue:f,cleanup:u}=(()=>{const e=new Map,t=new Map;let n;const c=()=>{n&&cancelAnimationFrame(n),n=requestAnimationFrame(a)},s=(e,t)=>{try{e()}catch(e){r(e,t,o)}},a=()=>{n=null;for(const[t,n]of e)for(const[e,c]of n)s(c(t),` Effect ${e} on ${t?.localName||"unknown"} failed`);e.clear();for(const e of t.values())s(e,"Cleanup failed");t.clear()};return queueMicrotask(a),{enqueue:(t,n,s)=>{e.has(t)||e.set(t,new Map);const o=e.get(t);o.has(n)||o.set(n,s),c()},cleanup:(e,n)=>{t.has(e)||t.set(e,n),c()}}})(),l=e=>{for(const t of e)t.run()},i=e=>c(e)&&s(e,"set"),d=e=>i(e)||(e=>c(e)&&s(e,"run")&&"effects"in e)(e),p=e=>{const t=()=>(a&&t.effects.add(a),e);return t.effects=new Set,t.set=c=>{const s=e;e=n(c)&&!d(c)?c(e):c,Object.is(e,s)||l(t.effects)},t},w=(e,t=!1)=>{let n,c=!0;const s=()=>{if(a&&s.effects.add(a),t&&!c)return n;const o=a;return a=s,n=e(),c=!1,a=o,n};return s.effects=new Set,s.run=()=>{c=!0,t&&l(s.effects)},s},h=e=>{const t=new Set,c=()=>{const s=a;a=c;const o=e(((e,n,c)=>{f(e,n,c),t.has(e)||t.add(e)}));n(o)&&u(c,o),a=s};c.run=()=>c(),c.targets=t,c()};export{p as cause,w as derive,h as effect,d as isSignal,i as isState};
