const e=e=>n=>typeof n===e,n=e("object"),t=e("function"),c="warn",a="error",o=(e,n,t="debug")=>([a,c].includes(t)&&console[t](n,e),e);let r;const{enqueue:l,cleanup:s}=(()=>{const e=new Map,n=new Map;let t;const c=(e,n)=>{try{e()}catch(e){o(e,n,a)}},r=()=>{t=null,e.forEach(((e,n)=>e.forEach(((e,t)=>c(e(n),`Effect ${t} on ${n?.localName||"unknown"} failed`))))),e.clear(),n.forEach((e=>c(e,"Cleanup failed"))),n.clear()},l=e=>(n,c)=>{const a=!e.has(n);e.set(n,c),a&&(t&&cancelAnimationFrame(t),t=requestAnimationFrame(r))};return queueMicrotask(r),{enqueue:(n,t,c)=>{return l((a=n,e.has(a)||e.set(a,new Map),e.get(a)))(t,c);var a},cleanup:l(n)}})(),u=e=>{r&&e.add(r)},i=e=>e.forEach((e=>e())),f=(e,n)=>{const t=r;r=n;try{e()}catch(e){o(e,"Error during reactive computation",a)}finally{r=t}},h=e=>(e=>(e=>null!=e)(e)&&(n(e)||t(e)))(e)&&t(e["set"]),p=e=>{const n=new Set,c=()=>(u(n),e);return c.set=c=>{const a=e;e=t(c)&&c.length?c(e):c,Object.is(e,a)||i(n)},c},d=(e,n=!1)=>{const t=new Set;let c,a=!0;const o=()=>{a=!0,n&&i(t)};return()=>(u(t),n&&!a||f((()=>{c=e(),a=(e=>null==e)(c)}),o),c)},w=e=>{const n=()=>f((()=>{const n=e(l);t(n)&&s(e,n)}),n);n()};export{p as cause,d as derive,w as effect,h as isState};
