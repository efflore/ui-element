const e=e=>t=>typeof t===e,t=e("object"),n=e("function"),c=e=>(e=>null!=e)(e)&&(t(e)||n(e)),o=(e,t)=>n(e[t]),s=e=>({map:()=>s(e),fold:t=>t(e),catch:t=>t(e)}),r=e=>{try{return t=e(),{map:e=>r((()=>e(t))),fold:(e,n)=>n(t),catch:()=>{}}}catch(e){return s(e)}var t},a="error",f=(e,t,n="debug")=>((e=>"warn"===e||e===a)(n)&&console[n](t,e),e);let u;const{enqueue:l,cleanup:d}=(()=>{const e=new Map,t=new Map;let n;const c=()=>{n&&cancelAnimationFrame(n),n=requestAnimationFrame(s)},o=(e,t)=>{r(e).catch((e=>f(e,t,a)))},s=()=>{n=null;for(const[t,n]of e)for(const[e,c]of n)o(c,` Effect ${e} on ${t?.localName||"unknown"} failed`);e.clear();for(const e of t.values())o(e,"Cleanup failed");t.clear()};return queueMicrotask(s),{enqueue:(t,n,o)=>{e.has(t)||e.set(t,new Map);const s=e.get(t);s.has(n)||s.set(n,o),c()},cleanup:(e,n)=>{t.has(e)||t.set(e,n),c()}}})(),i=e=>{for(const t of e)t.run()},p=e=>c(e)&&o(e,"set"),h=e=>p(e)||(e=>c(e)&&o(e,"run")&&"effects"in e)(e),w=e=>{const t=()=>(u&&t.effects.add(u),e);return t.effects=new Set,t.set=c=>{const o=e;e=n(c)&&!h(c)?c(e):c,Object.is(e,o)||i(t.effects)},t},m=(e,t=!1)=>{let n,c=!0;const o=()=>{if(u&&o.effects.add(u),t&&!c)return n;const s=u;return u=o,n=e(),c=!1,u=s,n};return o.effects=new Set,o.run=()=>{c=!0,t&&i(o.effects)},o},q=e=>{const t=new Set,c=()=>{const o=u;u=c;const s=e(((e,n,c)=>{l(e,n,c),t.has(e)||t.add(e)}));n(s)&&d(c,s),u=o};c.run=()=>c(),c.targets=t,c()};export{w as cause,m as derive,q as effect,h as isSignal,p as isState};
