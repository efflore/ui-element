const e=e=>n=>typeof n===e,n=e("object"),t=e("function"),o=e=>(e=>null!=e)(e)&&(n(e)||t(e)),c=(e,n)=>t(e[n]),r="warn",a="error",s=(e,n,t="debug")=>([a,r].includes(t)&&console[t](n,e),e),{enqueue:u,cleanup:l}=(()=>{const e=new Map,n=new Map;let t;const o=(e,n)=>{try{e()}catch(e){s(e,n,a)}},c=()=>{t=null;for(const[n,t]of e)for(const[e,c]of t)o(c(n),` Effect ${e} on ${n?.localName||"unknown"} failed`);e.clear();for(const e of n.values())o(e,"Cleanup failed");n.clear()},r=e=>(n,o)=>{const r=!e.has(n);e.set(n,o),r&&(t&&cancelAnimationFrame(t),t=requestAnimationFrame(c))};return queueMicrotask(c),{enqueue:(n,t,o)=>{return r((c=n,e.has(c)||e.set(c,new Map),e.get(c)))(t,o);var c},cleanup:r(n)}})();let f;const i=e=>{f&&e.add(f)},p=e=>{for(const n of e)n();e.clear()},d=(e,n)=>{const t=f;f=n;try{e()}catch(e){s(e,"Error during reactive computation:",a)}finally{f=t}},w=e=>o(e)&&c(e,"set"),m=e=>w(e)||(e=>o(e)&&c(e,"run")&&"effects"in e)(e),h=e=>{const n=new Set,o=()=>(i(n),e);return o.set=o=>{const c=e;e=t(o)?o(e):o,Object.is(e,c)||p(n)},o},q=(e,n=!1)=>{const t=new Set;let o,c=!0;return()=>(i(t),n&&!c||d((()=>{o=e(),c=!1}),(()=>{c=!0,n&&p(t)})),o)},y=e=>{const n=()=>d((()=>{const n=e(u);t(n)&&l(e,n)}),n);n()};export{h as cause,q as derive,y as effect,m as isSignal,w as isState};
