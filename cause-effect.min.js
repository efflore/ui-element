const t=t=>e=>typeof e===t,e=t("object"),n=t("function"),o=(t,o)=>(t=>(t=>null!=t)(t)&&(e(t)||n(t)))(t)&&Symbol.toStringTag in t&&t[Symbol.toStringTag]===o,a="warn",c="error",r=(t,e,n="debug")=>([c,a].includes(n)&&console[n](e,t),t),l="State",u="Computed";let s;const{enqueue:i,cleanup:g}=(()=>{const t=new Map,e=new Map;let n;const o=(t,e)=>{try{t()}catch(t){r(t,e,c)}},a=()=>{n=null,t.forEach(((t,e)=>t.forEach(((t,n)=>o(t(e),`Effect ${n} on ${e?.localName||"unknown"} failed`))))),t.clear(),e.forEach((t=>o(t,"Cleanup failed"))),e.clear()},l=t=>(e,o)=>{const c=!t.has(e);t.set(e,o),c&&(n&&cancelAnimationFrame(n),n=requestAnimationFrame(a))};return queueMicrotask(a),{enqueue:(e,n,o)=>{return l((a=e,t.has(a)||t.set(a,new Map),t.get(a)))(n,o);var a},cleanup:l(e)}})(),f=t=>{s&&t.add(s)},m=t=>t.forEach((t=>t())),S=(t,e)=>{const n=s;s=e;try{t()}catch(t){r(t,"Error during reactive computation",c)}finally{s=n}},p=t=>o(t,l),h=t=>o(t,u),d=t=>p(t)||h(t),y=t=>{const e=new Set;return{[Symbol.toStringTag]:l,get:()=>(f(e),t),set(o){const a=t;t=n(o)&&o.length?o(t):o,Object.is(t,a)||m(e)}}},b=(t,e=!1)=>{const n=new Set;let o,a=!0;const c=()=>{a=!0,e&&m(n)};return{[Symbol.toStringTag]:u,get:()=>(f(n),e&&!a||S((()=>{o=t(),a=(t=>null==t)(o)}),c),o)}},w=t=>{const e=()=>S((()=>{const e=t(i);n(e)&&g(t,e)}),e);e()};export{b as computed,w as effect,h as isComputed,d as isSignal,p as isState,y as state};
