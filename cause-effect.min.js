const t=(e="function",t=>typeof t===e);var e;const n=e=>t(e)?n(e()):e,s=e=>t(e)&&"type"in e,c=(e,n)=>e&&t(e[n]);let f;const o=t=>{for(const e of t)e.run()},r=e=>t(e)&&c(e,"set"),a=e=>r(e)||(e=>t(e)&&c(e,"run")&&"effects"in e)(e),u=e=>{const r=()=>(f&&r.effects.add(f),e);return r.effects=new Set,r.set=f=>{const a=e;e=t(f)&&!s(f)?(t=>s(t)&&c(t,"map"))(e)?e.map(f):f(e):f,!Object.is(n(e),n(a))&&o(r.effects)},r},d=(t,e=!1)=>{let n,s=!0;const c=()=>{if(f&&c.effects.add(f),e&&!s)return n;const o=f;return f=c,n=t(),s=!1,f=o,n};return c.effects=new Set,c.run=()=>{s=!0,e&&o(c.effects)},c},i=e=>{const n=new Map,s=()=>{const c=f;f=s;const o=e(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t)?.add(e)}));for(const t of n.values()){for(const e of t)e();t.clear()}f=c,t(o)&&queueMicrotask(o)};s.run=()=>s(),s.targets=n,s()};export{u as cause,d as derive,i as effect,a as isSignal,r as isState};