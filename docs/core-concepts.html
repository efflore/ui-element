<!doctype html>
<html>
	<head>
		<title>UIElement Docs ‚Äì Core Concepts</title>
		<link rel="stylesheet" href="assets/css/global.css">
		<link rel="stylesheet" href="assets/css/okaidia.css">
		<link rel="stylesheet" href="assets/css/components.css">
		<script type="module" src="assets/js/main.min.js"></script>
	</head>
	<body>
		<header class="content-grid">
			<h1 class="content">UIElement Docs <small>Version 0.8.5</small></h1>
			<nav class="breakout">
				<ol>
					<li>
						<a href="index.html">
							<span class="icon">üìò</span>
							<strong>Introduction</strong>
							<small>Overview and key benefits of UIElement</small>
						</a>
					</li>
					<li>
						<a href="installation-setup.html">
							<span class="icon">‚öôÔ∏è</span>
							<strong>Installation & Setup</strong>
							<small>How to install and set up the library</small>
						</a>
					</li>
					<li class="active">
						<a href="core-concepts.html">
							<span class="icon">üß©</span>
							<strong>Core Concepts</strong>
							<small>Learn about signals, state, and reactivity</small>
						</a>
					</li>
					<li>
						<a href="detailed-walkthrough.html">
							<span class="icon">üìã</span>
							<strong>Detailed Walkthrough</strong>
							<small>Step-by-step guide to creating components</small>
						</a>
					</li>
					<li>
						<a href="best-practices-patterns.html">
							<span class="icon">üí°</span>
							<strong>Best Practices & Patterns</strong>
							<small>Tips for effective and scalable usage</small>
						</a>
					</li>
					<li>
						<a href="advanced-topics.html">
							<span class="icon">üöÄ</span>
							<strong>Advanced Topics</strong>
							<small>Diving deeper into contexts and performance</small>
						</a>
					</li>
					<li>
						<a href="examples-recipes.html">
							<span class="icon">üß™</span>
							<strong>Examples & Recipes</strong>
							<small>Sample components and practical use cases</small>
						</a>
					</li>
					<li>
						<a href="troubleshooting-faqs.html">
							<span class="icon">‚ùì</span>
							<strong>Troubleshooting & FAQs</strong>
							<small>Common issues and frequently asked questions</small>
						</a>
					</li>
					<li>
						<a href="api-reference.html">
							<span class="icon">üìö</span>
							<strong>API Reference</strong>
							<small>Detailed documentation of classes and methods</small>
						</a>
					</li>
					<li>
						<a href="contributing-development.html">
							<span class="icon">ü§ù</span>
							<strong>Contributing & Development</strong>
							<small>How to contribute and set up the dev environment</small>
						</a>
					</li>
					<li>
						<a href="changelog-versioning.html">
							<span class="icon">üìù</span>
							<strong>Changelog & Versioning</strong>
							<small>Track changes and understand versioning</small>
						</a>
					</li>
					<li>
						<a href="licensing-credits.html">
							<span class="icon">‚öñÔ∏è</span>
							<strong>Licensing & Credits</strong>
							<small>License details and acknowledgments</small>
						</a>
					</li>
				</ol>				  
			</nav>
		</header>

		<main>
			<section class="hero">
				<h1>üß© Core Concepts</h1>
				<p class="lead">UIElement is a minimalist library that builds on the power of Web Components, extending them with lightweight, reactive state management.</p>
			</section>
		  
			<section>
				<h2>Anatomy of a Web Component</h2>

				<h3>Extending Web Components</h3>
				<p>UIElement extends the native <code>HTMLElement</code> class to add state management and reactivity to Web Components. You can create your own custom elements by extending <code>UIElement</code>.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
					<pre><code class="language-js">class MyComponent extends UIElement {
	/* component definition */
}</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
				</code-block>

				<h3>Defining Custom Elements</h3>
				<p>You must define the custom element's tag name in kebab-case using the <code>define()</code> method to make it available for use in HTML.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
					<pre><code class="language-js">MyComponent.define('my-component');</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
				</code-block>
				<p>Make sure to use valid custom element names and avoid defining the same element more than once.</p>

				<h3>Using the Custom Element</h3>
				<p>Once defined, you can use the custom element in HTML just like any other tag.</p>
				<code-block language="html" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">html</span>
					</p>
					<pre><code class="language-html">&lt;my-component&gt;Content goes here&lt;/my-component&gt;</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
				</code-block>
			</section>
		  
			<section>
				<h2>Web Components Lifecycle</h2>
				<p>Each UIElement component goes through a lifecycle. Here's how the core lifecycle callbacks work:</p>

				<h3>constructor()</h3>
				<p>Called when the element is created. You can't access attributes or DOM elements here yet; use <code>connectedCallback()</code> instead.</p>

				<h3>connectedCallback()</h3>
				<p>Called when the component is attached to the DOM. This is where you can initialize state, add event listeners, and set up reactive effects.</p>

				<h3>disconnectedCallback()</h3>
				<p>Called when the component is removed from the DOM. Clean up any external event listeners here.</p>

				<h3>adoptedCallback()</h3>
				<p>Called when the component is moved to a new document. Rarely needed unless you're dealing with advanced scenarios like drag-and-drop.</p>

				<h3>attributeChangedCallback()</h3>
				<p>Called when an observed attribute is changed. <code>UIElement</code> handles this automatically, so usually, there's no need to override it.</p>
			</section>
		  
			<section>
				<h2>Signals & State Management</h2>
				<p>Signals are the fundamental units of reactive state in UIElement. You can create and update signals using <code>this.set()</code>.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
					<pre><code class="janguage-js">this.set('count', 0); // Create a signal
this.set('isEven', () => this.get('count') % 2 === 0); // Create a derived signal</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
			    </code-block>
				<p>Signals automatically notify derived signals and effects that use them with <code>this.get()</code> whenever they change.</p>
				<p>You can check whether a signal has been defined using <code>this.has()</code>.</p>
				<p>Use <code>this.delete()</code> to remove a signal and its bound derived signals and effects.</p>
				<p>The <code>Map</code> interface for signals on UIElement Web Components constitutes the public interface for parent components to pass client state to. Prefer setting signals on components to setting attributes, as attributes are converted to strings and back.</p>
			</section>

			<section>
				<h2>Attributes & State Initialization</h2>
				<p>Observed attributes in UIElement are automatically converted into reactive signals. You can declare them using the <code>observedAttributes</code> static property.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
					<pre><code class="language-js">static observedAttributes = ['count'];</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
                </code-block>
				<p>To parse and map attributes to specific state types, use the <code>attributeMap</code> static property.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
					<pre><code class="language-js">static attributeMap = {
	count: asInteger,
}</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
				</code-block>
				<p>You can also use custom parsing functions for more complex attribute handling.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
				<pre><code class="language-js">static attributeMap = {
	date: value => value.map(v => new Date(v)),
}</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
				</code-block>
				<p>Attributes are the preferred way to pass pieces of state from the server to the client component. Server-rendered HTML populates attributes directly on the custom elements that need this specific piece of state. This is how we avoid props drilling, an anti-pattern common in JS frameworks, in UIElement. Only state that may change on the client should be declared as observed attributes.</p>
			</section>

			<section>
				<h2>Events & State Changes</h2>
				<p>Use <code>.map()</code> and <code>on()</code> to attach event listeners to elements. These event handlers can trigger state changes and update the DOM.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
                    <pre><code class="language-js">this.first('.increment').map(on('click', () => this.set('count', v => ++v)));</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
                </code-block>
				<p>User interactions like clicks or form inputs can trigger signal updates, which will be reflected in the DOM everywhere the signal is being used on the next screen refresh.</p>
			</section>
		  
			<section>
				<h2>Effects & Reactive Bindings</h2>
				<p>UIElement uses effects to manage side-effects to the DOM, external APIs and the server.</p>
				<p>For the most common DOM manipulations UIElement provides auto-effects like <code>setText()</code> to automatically update the text content when signals change. Use the chainable <code>.map()</code> method to bind auto-effects for signals to HTML elements.</p>
				<code-block language="js" copy-success="Copied!" copy-error="Error trying to copy to clipboard!">
					<p class="meta">
						<span class="language">js</span>
					</p>
                    <pre><code class="language-js">this.first('.count').map(setText('count'));</code></pre>
					<input-button class="copy">
						<button type="button" class="secondary small">Copy</button>
					</input-button>
                </code-block>
				<p>The content of the <code>.count</code> element will update whenever the <code>count</code> signal changes.</p>

				<h3>Efficient & Fine-Grained Updates</h3>
				<p>UIElement efficiently updates only the parts of the DOM affected by signal changes, avoiding full re-renders. This ensures optimal performance and precise updates.</p>
				<p>Unlike virtual DOM approaches, UIElement never diffs or re-renders the static parts in a component.</p>
			</section>
		  
			<section>
				<h2>Outlook: State Sharing & Context</h2>
				<p>While most components manage their own state, sometimes you need to share state between components. UIElement allows this through <code>pass()</code> for parent-child state sharing and context providers for more advanced scenarios.</p>
				<p>These advanced features will be covered in detail in later sections on <a href="best-practices-patterns.html">Best Practices & Patterns</a> and <a href="advanced-topics.html">Advanced Topics</a>.</p>
				<p>To learn more about the data flow within a component, pre-defined attribute parsers and auto-effects to update the DOM continue with our <a href="detailed-walkthrough.html">Detailed Walkthrough</a>.</p>
			</section>

		</main>
		  
	</body>
</html>