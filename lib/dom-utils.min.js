import t,{effect as e,unwrap as s}from"../index.js";const o=!0,a="data-",r="-text",i="-prop",c="-attr",l="-class",n="-style",d="-hover",u="-focus",g=t=>void 0!==t,h=(t,e,s)=>{t.hasAttribute(e)&&(s(t,t.getAttribute(e)),t.removeAttribute(e));for(const o of(t.shadowRoot||t).querySelectorAll(`[${e}]`))s(o,o.getAttribute(e)),o.removeAttribute(e)},f=t=>`<${t.localName}${t.id&&`#${t.id}`}${t.className&&`.${t.className.replace(" ",".")}`}>`,b=t=>"string"==typeof t?`"${t}"`:"object"==typeof t?JSON.stringify(t):g()?t.toString():"undefined",$=(t,e,o=e)=>{Array.from(t.childNodes).filter((t=>t.nodeType!==Node.COMMENT_NODE)).forEach((t=>t.remove())),t.append(document.createTextNode(s(o)))},p=(t,e,s)=>{g(s)?t[e]=s:delete t[e]},m=(t,e,o)=>{"boolean"==typeof o?t.toggleAttribute(e,o):g(o)?t.setAttribute(e,s(o)):t.removeAttribute(e)},y=(t,e,o)=>{t.classList.toggle(e,s(o))},A=(t,e,o)=>{g(o)?t.style.setProperty(e,s(o)):t.style.removeProperty(e)},C=t=>{[r,i,c,l,n].forEach((s=>{const o=`${a}${t.localName}${s}`;h(t,o,s===r?(s,o)=>{const a=o.trim(),r=s.textContent||"";t.set(a,r,!1),e((e=>{if(t.has(a)){const o=t.get(a);e(s,$,!0,g(o)?o:r)}}))}:(o,a)=>{const r=(t,e)=>t.split(e).map((t=>t.trim())),[d,u]={[i]:[t=>o[t],p],[c]:[t=>o.getAttribute(t),m],[l]:[t=>o.classList.contains(t),y],[n]:[t=>o instanceof HTMLElement&&o.style[t],A]}[s];r(a,";").forEach((s=>{let[a,i]=r(s,":");!i&&(i=a),t.set(i,d(a),!1),e((e=>{t.has(i)&&e(o,u,a,t.get(i))}))}))})}))},v=(t,e="ui-effect")=>{[d,u].forEach((s=>{const[o,r]=s===d?["mouseenter","mouseleave"]:["focus","blur"];h(t,`${a}${t.localName}${s}`,((s,a)=>{const i=a.trim(),c=(o,a)=>s.addEventListener(o,(()=>{for(const s of t.targets(i))s.classList.toggle(e,a)}));c(o,!0),c(r,!1)}))}))};export default class k extends t{connectedCallback(){"string"==typeof this.getAttribute("debug")&&this.set("debug",!0),this.log(`Connected ${f(this)}`)}disconnectedCallback(){this.log(`Disconnected ${f(this)}`)}adoptedCallback(){this.log(`Adopted ${f(this)}`)}attributeChangedCallback(t,e,s){this.log(`Attribute "${t}" of ${f(this)} changed from ${b(e)} to ${b(s)}`),super.attributeChangedCallback(t,e,s)}get(t){const e=super.get(t);return this.log(`Get current value of state ${b(t)} in ${f(this)} (value: ${b(e)}) and track its use in effect`),e}set(t,e,s=!0){this.log(`Set ${s?"":"default "}value of state ${b(t)} in ${f(this)} to ${b(e)} and trigger dependent effects`),super.set(t,e,s)}delete(t){return this.log(`Delete state ${b(t)} from ${f(this)}`),super.delete(t)}async pass(t,e,s=customElements){this.log(`Pass state(s) ${b(Object.keys(e))} to ${f(t)} from ${f(this)}`),super.pass(t,e,s)}log(t){this.has("debug")&&console.debug(t)}}const N=(t,e={},s,o)=>{const a=class extends k{static observedAttributes=Object.keys(e);attributeMap=e;connectedCallback(){super.connectedCallback(),s&&s(this),C(this),v(this)}disconnectedCallback(){super.disconnectedCallback(),o&&o(this)}};return a.define(t),a};export{o as DEV_MODE,N as component,$ as setText,m as setAttr,y as setClass,p as setProp,A as setStyle,C as autoEffects,v as highlightTargets,k as DebugElement};