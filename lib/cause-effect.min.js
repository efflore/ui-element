let t;const e=(t,...o)=>{const s=o.shift();!t.has(s)&&t.set(s,new Map);const n=t.get(s);return o.length?e(n,...o):n},o=t=>"function"==typeof t,s=t=>o(t)&&o(t.set),n=e=>{const n=()=>(t&&n.effects.add(t),e);return n.effects=new Set,n.set=t=>{const c=e;if(e=o(t)&&!s(t)?t(c):t,!Object.is(e,c))for(const t of n.effects)t()},n},c=t=>t,f=s=>{const[n,c,f]=(()=>{const t=new Map;return[t,(o,s,n,c)=>{e(t,o,s).set(n,c)},()=>{for(const[e,o]of t)for(const[t,s]of o)for(const[o,n]of s)t(e,o,n)}]})(),r=()=>{const e=t;t=r;const n=s(c);t=e,queueMicrotask((()=>{f(),o(n)&&n()}))};r.targets=n,r()};export{n as cause,c as derive,f as effect,o as isFunction,s as isState};