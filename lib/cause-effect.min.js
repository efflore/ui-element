let t;const e=t=>"function"==typeof t,o=t=>e(t)&&e(t.set),s=(t,...e)=>{const o=e.shift();!t.has(o)&&t.set(o,new Map);const n=t.get(o);return e.length?s(n,...e):n},n=s=>{const n=()=>(t&&n.effects.add(t),s);return n.effects=new Set,n.set=t=>{const c=s;if(s=e(t)&&!o(t)?t(c):t,!Object.is(s,c))for(const t of n.effects)t()},n},c=t=>t,f=o=>{const[n,c,f]=(()=>{const t=new Map;return[t,(e,o,n,c)=>{s(t,e,o).set(n,c)},()=>{for(const[e,o]of t)for(const[t,s]of o)for(const[o,n]of s)t(e,o,n)}]})(),r=()=>{const s=t;t=r;const n=o(c);t=s,queueMicrotask((()=>{f(),e(n)&&n()}))};r.targets=n,r()};export{n as cause,c as derive,f as effect,e as isFunction,o as isState,s as nestMap};