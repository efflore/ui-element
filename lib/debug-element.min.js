import t from"../index.js";const e=t=>`<${t.localName+(t.id&&"#"+t.id)+(t.className&&"."+t.className)}>`,s=t=>"string"==typeof t?`'${t}'`:t.toString();export default class extends t{debug=!1;connectedCallback(){"string"==typeof this.getAttribute("debug")&&(this.debug=!0),this.log(`Connected ${e(this)}`)}disconnectedCallback(){this.log(`Disconnected ${e(this)}`)}adoptedCallback(){this.log(`Adopted ${e(this)}`)}attributeChangedCallback(t,s,i){this.log(`Attribute '${t}' of ${e(this)} changed from '${s}' to '${i}'`),super.attributeChangedCallback(t,s,i)}get(t){const i=super.get(t);return this.log(`Get current value of state '${String(t)}' in ${e(this)} (value: ${s(i)}) and track its use in effect`),i}set(t,i,o=!0){this.log(`Set ${o?"":"default "}value of state '${String(t)}' in ${e(this)} to ${s(i)} and trigger dependent effects`),super.set(t,i,o)}effect(t){if(!this.debug)return super.effect(t);"function"!=typeof t&&this.error(new TypeError(`Effect handler in ${e(this)} is not a function`));const s=i=>{if(t.targets=new Map,t(i),s.targets.size){const t=[];for(const i of s.targets.keys())t.push(e(i));console.log(`Effect updated ${t.join(", ")} in ${e(this)}`)}};s.targets=t.targets,super.effect(s)}log(t){this.debug&&console.debug(t)}error(t){throw t}}