const t="context-request";class s extends Event{context;callback;subscribe;constructor(s,e,n=!1){super(t,{bubbles:!0,composed:!0}),this.context=s,this.callback=e,this.subscribe=n}}const e=t=>"function"==typeof t,n=t=>e(t)&&e(t.set);let o;const c=t=>{const s=()=>(o&&s.effects.add(o),t);return s.effects=new Set,s.set=o=>{const c=t;if(t=e(o)&&!n(o)?o(c):o,!Object.is(t,c))for(const t of s.effects)t()},s},a=t=>{const s=new Map,n=()=>{const c=o;o=n;const a=t(((t,e)=>{!s.has(t)&&s.set(t,new Set),s.get(t).add(e)}));o=c,queueMicrotask((()=>{for(const t of s.values())for(const s of t)s();e(a)&&a()}))};n.targets=s,n()};class r extends HTMLElement{static define(t,s=customElements){try{s.get(t)||s.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,s,n){if(n!==s){const o=this.attributeMap[t],[c,a]=Array.isArray(o)?o:[t,o];this.set(c,e(a)?a(n,this,s):n)}}connectedCallback(){const n=Object.getPrototypeOf(this),o=n.providedContexts||[];o.length&&this.addEventListener(t,(t=>{const{context:s,callback:n}=t;o.includes(s)&&e(n)&&(t.stopPropagation(),n(this.#t.get(s)))})),setTimeout((()=>{n.consumedContexts?.forEach((t=>{const n=new s(t,(s=>{const n=this.contextMap[t],[o,c]=Array.isArray(n)?n:[t,n];this.#t.set(o||t,e(c)?c(s,this):s)}));this.dispatchEvent(n)}))}))}has(t){return this.#t.has(t)}get(t){const s=t=>e(t)?s(t()):t;return s(this.#t.get(t))}set(t,s,e=!0){if(this.#t.has(t)){const o=this.#t.get(t);e&&n(o)&&o.set(s)}else{const e=n(s)?s:c(s);this.#t.set(t,e)}}delete(t){return this.#t.delete(t)}async pass(t,s,n=customElements){await n.whenDefined(t.localName);for(const[n,o]of Object.entries(s))t.set(n,c(e(o)?o:this.#t.get(o)))}targets(t){const s=new Set;for(const e of this.#t.get(t).effects)for(const t of e.targets.keys())s.add(t);return s}}const i=t=>"string"==typeof t,f=t=>parseInt(t,10),h=t=>parseFloat(t),l=t=>t;export{s as ContextRequestEvent,i as asBoolean,f as asInteger,h as asNumber,l as asString,r as default,a as effect};