const t=t=>e=>typeof e===t,e=t("symbol"),r=t("number"),s=t("string"),n=t("object"),a=t=>s(t)||e(t)||r(t),o=t("function"),i=(t,...e)=>o(t)?t(...e):void 0,l=t=>null===t,c=t=>null==t,u=t=>null!=t,d=t=>u(t)&&(n(t)||o(t)),g=(t,e)=>d(t)&&Symbol.toStringTag in t&&t[Symbol.toStringTag]===e,p=t=>t.nodeType===Node.COMMENT_NODE,b="debug",h="info",m="warn",f="error",y=t=>{return`<${t.localName}${r=t.id,r?`#${r}`:""}${e=t.classList,e.length?`.${Array.from(e).join(".")}`:""}>`;var e,r},$=t=>s(t)?`"${t}"`:n(t)?JSON.stringify(t):u(t)?String(t):"undefined",S=(t,e,r=b)=>([f,m].includes(r)&&console[r](e,t),t),v="Ok",A="None",k="Fail",w=t=>({[Symbol.toStringTag]:v,value:t,map:e=>w(e(t)),flatMap:e=>e(t),filter:e=>e(t)?w(t):x(),guard:e=>e(t)?w(t):x(),or:()=>w(t),get:()=>t}),x=()=>{const t=()=>x();return{[Symbol.toStringTag]:A,map:t,flatMap:t,filter:t,guard:t,or:t=>O(t),get:()=>{}}},E=t=>{const e=()=>E(t);return{[Symbol.toStringTag]:k,error:t,map:e,flatMap:e,filter:e,guard:e,or:t=>O(t),get:()=>{throw t}}},C=t=>g(t,v),M=t=>g(t,A),N=t=>g(t,k),T=t=>C(t)||M(t)||N(t),O=t=>u(t)?w(t):x(),L=t=>{try{return O(t())}catch(t){return E(t)}},q=(t,e=0,r=1e3)=>{const s=async(e,r)=>{const n=L((async()=>await t()));return await j({[k]:async t=>e<1?E(t):(await new Promise((t=>setTimeout(t,r))),s(e-1,2*r))})(n)};return s(e,r)},F=(...t)=>t.reduce(((t,e)=>i(e,t))),j=t=>e=>{const r=t[e[Symbol.toStringTag]]||t.else,s=(t,e)=>t&&e in t&&t[e]||void 0,n=O(s(e,"value")).or(s(e,"error")).get();return O(r).guard(o).map((t=>t(n))).or(n).get()},U="State",P="Computed";let I;const{enqueue:J,cleanup:R}=(()=>{const t=new Map,e=new Map;let r;const s=(t,e)=>{const r=L(t);j({[k]:t=>S(t,e,f)})(r)},n=()=>{r=null,t.forEach(((t,e)=>t.forEach(((t,r)=>s(t(e),`Effect ${r} on ${e?.localName||"unknown"} failed`))))),t.clear(),e.forEach((t=>s(t,"Cleanup failed"))),e.clear()},a=t=>(e,s)=>{const a=!t.has(e);t.set(e,s),a&&(r&&cancelAnimationFrame(r),r=requestAnimationFrame(n))};return queueMicrotask(n),{enqueue:(e,r,s)=>{return a((n=e,t.has(n)||t.set(n,new Map),t.get(n)))(r,s);var n},cleanup:a(e)}})(),D=t=>{I&&t.add(I)},H=t=>t.forEach((t=>t())),V=(t,e)=>{const r=I;I=e;const s=L(t);j({[k]:t=>S(t,"Error during reactive computation",f)})(s),I=r},_=t=>g(t,U),z=t=>g(t,P),B=t=>_(t)||z(t),G=t=>{const e=new Set;return{[Symbol.toStringTag]:U,get:()=>(D(e),t),set(r){const s=t;t=o(r)&&r.length?r(t):r,Object.is(t,s)||H(e)},get targets(){return[...e]}}},K=(t,e=!1)=>{const r=new Set;let s,n=!0;const a=()=>{n=!0,e&&H(r)};return{[Symbol.toStringTag]:P,get:()=>(D(r),e&&!n||V((()=>{s=t(),n=c(s)}),a),s),get targets(){return[...r]}}},Q=t=>{const e=()=>V((()=>O(t(J)).guard(o).map((e=>R(t,e)))),e);e()},W="UI",X=(t,e=t)=>({[Symbol.toStringTag]:"UI",host:t,target:e}),Y=t=>w(X(t)),Z=t=>e=>O(t.root.querySelector(e)).map((e=>X(t,e))),tt=t=>e=>Array.from(t.root.querySelectorAll(e)).map((e=>X(t,e))),et=(t,e,r,s=void 0)=>{const n=t.constructor.attributeMap[e];return(t=>o(t)&&!!t.length)(n)?n(O(r),t,s):r},rt="debug";class st extends HTMLElement{static registry=customElements;static attributeMap={};static observedAttributes;static consumedContexts;static providedContexts;static define(t){const e=L((()=>st.registry.define(t,this)));j({[k]:e=>S(t,e.message,f),[v]:()=>false})(e)}signals=new Map;internals;self=Y(this);root=this.shadowRoot||this;attributeChangedCallback(t,e,r){r!==e&&this.set(t,et(this,t,r,e))}connectedCallback(){s(this.getAttribute(rt))&&(this[rt]=!0)}disconnectedCallback(){}adoptedCallback(){}has(t){return this.signals.has(t)}get(t){const e=t=>d(t)?o(t)?e(t()):B(t)||T(t)?e(t.get()):t:t;return e(this.signals.get(t))}set(t,e,r=!0){if(N(e))return void S(e.error,`Unhandled error before trying to set state '${t}' in <${this.localName}>`,f);const s=T(e)?e.get():e;if(this.signals.has(t)){if(r){const e=this.signals.get(t);B(s)?(this.signals.set(t,s),e.targets.forEach((t=>t()))):_(e)?e.set(s):S(s,`Computed state ${$(t)} in ${y(this)} cannot be set`,f)}}else this.signals.set(t,B(s)?s:G(s))}delete(t){return this.signals.delete(t)}first=Z(this);all=tt(this)}const nt="context-request";class at extends Event{context;callback;subscribe;constructor(t,e,r=!1){super(nt,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=r}}const ot=t=>{const e=t.constructor,r=e.consumedContexts||[];setTimeout((()=>{for(const e of r)t.dispatchEvent(new at(e,(r=>t.set(String(e),r))))}));const s=e.providedContexts||[];return!!s.length&&(t.addEventListener(nt,(e=>{const{context:r,callback:n}=e;s.includes(r)&&o(n)&&(e.stopPropagation(),n(t.signals.get(String(r))))})),!0)},it=t=>async e=>{await e.host.constructor.registry.whenDefined(e.target.localName);for(const[r,s=r]of Object.entries(t)){const t=a(s)?e.host.signals.get(s):B(s)?s:o(s)?G(s):e.host.signals.get(s);e.target.set(r,t)}return e},lt=(t,e)=>r=>(r.target.addEventListener(t,e),r),ct=(t,e)=>r=>(r.target.removeEventListener(t,e),r),ut=(t,e=t)=>r=>(Q((()=>{r.target.dispatchEvent(new CustomEvent(t,{detail:r.host.get(e),bubbles:!0}))})),r),dt=t=>O(u(t.get())),gt=t=>t.map((t=>parseInt(t,10))).filter(Number.isFinite),pt=t=>t.map(parseFloat).filter(Number.isFinite),bt=t=>t,ht=t=>e=>e.filter((e=>t.includes(e.toLowerCase()))),mt=t=>{const e=L((()=>t.map((t=>JSON.parse(t)))));return j({[k]:t=>(S(t,"Failed to parse JSON",f),x())})(e)},ft=(t,e)=>r=>{const{key:n,read:a,update:i}=e,{host:u,target:d}=r,g=a(d);if(!o(t)){const e=s(t)&&s(g)?et(u,t,g):g;u.set(t,e,!1)}return Q((r=>{const s=a(d),p=o(t)?t(s):u.get(t);if(!Object.is(p,s)){const t=l(p)&&e.delete?e.delete:c(p)?i(g):i(p);r(d,n,t)}})),r},yt=t=>ft(t,{key:"t",read:t=>t.textContent||"",update:t=>e=>()=>{Array.from(e.childNodes).filter((t=>!p(t))).forEach((t=>t.remove())),e.append(document.createTextNode(t))}}),$t=(t,e=t)=>ft(e,{key:`p:${String(t)}`,read:e=>e[t],update:e=>r=>()=>r[t]=e}),St=(t,e=t)=>ft(e,{key:`a:${t}`,read:e=>e.getAttribute(t),update:e=>r=>()=>r.setAttribute(t,e),delete:e=>()=>e.removeAttribute(t)}),vt=(t,e=t)=>ft(e,{key:`a:${t}`,read:e=>e.hasAttribute(t),update:e=>r=>()=>r.toggleAttribute(t,e)}),At=(t,e=t)=>ft(e,{key:`c:${t}`,read:e=>e.classList.contains(t),update:e=>r=>()=>r.classList.toggle(t,e)}),kt=(t,e=t)=>ft(e,{key:`s:${t}`,read:e=>e.style.getPropertyValue(t),update:e=>r=>()=>r.style.setProperty(t,e),delete:e=>()=>e.style.removeProperty(t)}),wt="aria",xt="button",Et="checkbox",Ct="columnheader",Mt="gridcell",Nt="menuitemcheckbox",Tt="menuitemradio",Ot="option",Lt="row",qt="rowheader",Ft="switch",jt="tab",Ut="treeitem",Pt="busy",It="checked",Jt="current",Rt="disabled",Dt="expanded",Ht="hidden",Vt="pressed",_t="selected",zt=["false","mixed","true"],Bt=["date","false","location","page","step","time","true"],Gt=[Et,Nt,Tt,Ot,"radio",Ft,Ut],Kt=["application",xt,Et,Ct,"combobox",Mt,"link","listbox","menuitem",Nt,Tt,Lt,qt,Ft,jt,Ut],Qt=[Ct,Mt,Ot,Lt,qt,jt,Ut],Wt=t=>{return Array.isArray(t)?t:[t,wt+(e=t,e.charAt(0).toUpperCase()+e.slice(1))];var e},Xt=(t,e)=>e.includes(t),Yt=(t,e,r,s)=>!!Xt(t,e)||(S(t,`Role for ${y(r)} does not support aria-${s}. Use one of ${$(e)}`,m),!1),Zt=(t,e,r)=>{const s=t.role,[n,a]=Wt(e);return!(Array.isArray(r)&&!Yt(s,r,t,n))&&(ee(n,`${wt}${a}`)(t),!0)},te=(t,e)=>r=>{if(!r.internals)return;const{key:s,parser:n,initial:a,read:i,update:l}=e;r.constructor.attributeMap[s]=n,r.set(t,a(r),!1),Q((n=>{const a=i(r),u=o(t)?t(a):r.get(t),d=c(u)&&e.delete?e.delete:l(u);Object.is(u,a)||n(r,s,d)}))},ee=(t,e)=>te(t,{key:`i-${t}`,parser:dt,initial:e=>e.hasAttribute(t),read:e=>e.internals.states.has(t),update:r=>s=>()=>{s.internals.states[r?"add":"delete"](t),e&&(s.internals[e]=String(r),s.setAttribute(`${wt}-${t}`,String(r))),s.toggleAttribute(t,r)}}),re=(t,e,r)=>te(t,{key:`i-${t}`,parser:r,initial:e=>e.getAttribute(`aria-${t}`),read:r=>et(r,t,r.internals[e]),update:r=>s=>()=>{s.internals[e]=r,s.setAttribute(`${wt}-${t}`,r)},delete:r=>()=>{r.internals[e]=void 0,r.removeAttribute(`${wt}-${t}`)}}),se=t=>{t.internals||(t.internals=t.attachInternals());const e=t.constructor,r=new Map([[Pt,ne],[Jt,oe],[Rt,ie],[Ht,ce]]),s=t.role;Gt.includes(s)&&r.set(It,ae),Kt.includes(s)&&r.set(Dt,le),s===xt&&r.set(Vt,ue),Qt.includes(s)&&r.set(_t,de);for(const[s,n]of r)e.observedAttributes.includes(s)&&n(t);return!0},ne=t=>(t.internals.ariaLive="polite",Zt(t,Pt)),ae=(t,e=!1)=>{const r=t.role,[s,n]=Wt(It);if(!Yt(r,Gt,t,s))return!1;const a=[Et,Nt,Ot];return e&&!Xt(r,a)&&e&&(S(r,`Role for ${y(t)} does not support tri-state aria-checked. Use one of ${$(a)} instead.`,m),e=!1),e?re(s,`${wt}${n}`,ht(zt))(t):ee(s,`${wt}${n}`)(t),!0},oe=(t,e=!1)=>(e?((t,e,r,s)=>{const n=t.role,[a,o]=Wt(e);Array.isArray(s)&&!Yt(n,s,t,a)||re(a,`${wt}${o}`,r)(t)})(t,Jt,ht(Bt)):Zt(t,Jt),!0),ie=t=>Zt(t,Rt),le=t=>Zt(t,Dt,Kt),ce=t=>Zt(t,Ht),ue=(t,e=!1)=>{const r=t.role,[s,n]=Wt(Vt);return!!Yt(r,[xt],t,s)&&(e?re(s,`${wt}${n}`,ht(zt))(t):ee(s,`${wt}${n}`)(t),!0)},de=t=>Zt(t,_t,Qt);export{b as LOG_DEBUG,f as LOG_ERROR,h as LOG_INFO,m as LOG_WARN,P as TYPE_COMPUTED,k as TYPE_FAIL,A as TYPE_NONE,v as TYPE_OK,U as TYPE_STATE,W as TYPE_UI,st as UIElement,tt as all,dt as asBoolean,ht as asEnum,gt as asInteger,mt as asJSON,pt as asNumber,bt as asString,i as callFunction,K as computed,Q as effect,y as elementName,ut as emit,E as fail,Z as first,F as flow,p as isComment,z as isComputed,u as isDefined,d as isDefinedObject,N as isFail,o as isFunction,M as isNone,l as isNull,c as isNullish,r as isNumber,n as isObject,g as isObjectOfType,C as isOk,a as isPropertyKey,T as isResult,B as isSignal,_ as isState,s as isString,e as isSymbol,S as log,j as match,O as maybe,x as none,ct as off,w as ok,lt as on,et as parse,it as pass,L as result,Y as self,St as setAttribute,re as setInternal,$t as setProperty,kt as setStyle,yt as setText,G as state,q as task,vt as toggleAttribute,At as toggleClass,ee as toggleInternal,X as ui,ft as updateElement,ne as useBusy,ae as useChecked,ot as useContext,oe as useCurrent,ie as useDisabled,le as useExpanded,ce as useHidden,se as useInternals,ue as usePressed,de as useSelected,$ as valueString};
