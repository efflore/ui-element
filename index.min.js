let t;const e=t=>"function"==typeof t,s=t=>e(t)&&e(t.set),n=n=>{const o=()=>(t&&o.effects.add(t),n);return o.effects=new Set,o.set=t=>{const c=n;n=e(t)&&!s(t)?t(c):t,!Object.is(n,c)&&(t=>{for(const e of t)e.run()})(o.effects)},o},o=s=>{const n=new Map,o=()=>{const c=t;t=o;const a=s(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t)?.add(e)}));for(const t of n.values())for(const e of t)e();t=c,e(a)&&queueMicrotask(a)};o.run=()=>o(),o.targets=n,o()},c="context-request";class a extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(c,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const r=(t,s)=>Array.isArray(t)?t:[s,e(t)?t:t=>t];class i extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,s,n){if(n===s)return;const[o,c]=r(this.attributeMap[t],t);this.set(o,e(c)?c(n,this,s):n)}connectedCallback(){const t=Object.getPrototypeOf(this);setTimeout((()=>{t.consumedContexts?.forEach((t=>{const s=new a(t,(s=>{if("string"!=typeof t)return;const[n,o]=r(this.contextMap[t],t);this.set(n||t,e(o)?o(s,this):s)}));this.dispatchEvent(s)}))}));const s=t.providedContexts||[];s.length&&this.addEventListener(c,(t=>{const{context:n,callback:o}=t;"string"==typeof n&&s.includes(n)&&e(o)&&(t.stopPropagation(),o(this.#t.get(n)))}))}has(t){return this.#t.has(t)}get(t){const s=t=>e(t)?s(t()):t;return s(this.#t.get(t))}set(t,e,o=!0){if(this.#t.has(t)){const n=this.#t.get(t);o&&s(n)&&n.set(e)}else this.#t.set(t,s(e)?e:n(e))}delete(t){return this.#t.delete(t)}async pass(t,s,o=customElements){await o.whenDefined(t.localName);for(const[o,c]of Object.entries(s))t.set(o,n(e(c)?c:this.#t.get(c)))}targets(t){const e=new Set,s=this.#t.get(t);if(!s||!s.effects)return e;for(const t of s.effects){const s=t.targets?.keys();if(s)for(const t of s)e.add(t)}return e}}export{i as default,o as effect};