let t;const e=t=>"function"==typeof t,s=t=>e(t)&&e(t.set),n=n=>{const c=()=>(t&&c.effects.add(t),n);return c.effects=new Set,c.set=t=>{const o=n;if(n=e(t)&&!s(t)?t(o):t,!Object.is(n,o))for(const t of c.effects)t()},c},c=s=>{const n=new Map,c=()=>{const o=t;t=c;const a=s(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t).add(e)}));t=o,queueMicrotask((()=>{for(const t of n.values())for(const e of t)e();e(a)&&a()}))};c.targets=n,c()},o="context-request";class a extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(o,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class r extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,s,n){if(n!==s){const c=this.attributeMap[t],[o,a]=Array.isArray(c)?c:[t,c];this.set(o,e(a)?a(n,this,s):n)}}connectedCallback(){const t=Object.getPrototypeOf(this),s=t.providedContexts||[];s.length&&this.addEventListener(o,(t=>{const{context:n,callback:c}=t;s.includes(n)&&e(c)&&(t.stopPropagation(),c(this.#t.get(n)))})),setTimeout((()=>{t.consumedContexts?.forEach((t=>{const s=new a(t,(s=>{const n=this.contextMap[t],[c,o]=Array.isArray(n)?n:[t,n];this.#t.set(c||t,e(o)?o(s,this):s)}));this.dispatchEvent(s)}))}))}has(t){return this.#t.has(t)}get(t){const s=t=>e(t)?s(t()):t;return s(this.#t.get(t))}set(t,e,c=!0){if(this.#t.has(t)){const n=this.#t.get(t);c&&s(n)&&n.set(e)}else{const c=s(e)?e:n(e);this.#t.set(t,c)}}delete(t){return this.#t.delete(t)}async pass(t,s,c=customElements){await c.whenDefined(t.localName);for(const[c,o]of Object.entries(s))t.set(c,n(e(o)?o:this.#t.get(o)))}targets(t){const e=new Set;for(const s of this.#t.get(t).effects)for(const t of s.targets.keys())e.add(t);return e}}export{r as default,c as effect};