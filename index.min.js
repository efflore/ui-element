const t=(e="function",t=>typeof t===e);var e;let s;const n=e=>t(e)&&t(e.set),o=e=>{const o=()=>(s&&o.effects.add(s),e);return o.effects=new Set,o.set=s=>{const c=e;e=t(s)&&!n(s)?s(c):s,!Object.is(e,c)&&(t=>{for(const e of t)e.run()})(o.effects)},o},c=e=>{const n=new Map,o=()=>{const c=s;s=o;const a=e(((t,e)=>{!n.has(t)&&n.set(t,new Set),n.get(t)?.add(e)}));for(const t of n.values())for(const e of t)e();s=c,t(a)&&queueMicrotask(a)};o.run=()=>o(),o.targets=n,o()},a="context-request";class r extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(a,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class i extends HTMLElement{static consumedContexts;static providedContexts;static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(e,s,n){if(n===s)return;const o=this.attributeMap[e];this.set(e,t(o)?o(n,this,s):n)}connectedCallback(){const e=this.constructor,s=e.consumedContexts||[];for(const t of s)this.set(String(t),void 0);setTimeout((()=>{for(const t of s)this.dispatchEvent(new r(t,(e=>this.set(String(t),e))))}));const n=e.providedContexts||[];n.length&&this.addEventListener(a,(e=>{const{context:s,callback:o}=e;n.includes(s)&&t(o)&&(e.stopPropagation(),o(this.#t.get(String(s))))}))}has(t){return this.#t.has(t)}get(e){const s=e=>t(e)?s(e()):e;return s(this.#t.get(e))}set(t,e,s=!0){if(this.#t.has(t)){const o=this.#t.get(t);s&&n(o)&&o.set(e)}else this.#t.set(t,n(e)?e:o(e))}delete(t){return this.#t.delete(t)}async pass(e,s,n=customElements){await n.whenDefined(e.localName);for(const[n,c]of Object.entries(s))e.set(n,o(t(c)?c:this.#t.get(c)))}targets(t){const e=new Set,s=this.#t.get(t);if(!s||!s.effects)return e;for(const t of s.effects){const s=t.targets?.keys();if(s)for(const t of s)e.add(t)}return e}}export{i as default,c as effect};