/**
 * @license
 * Copyright 2024 Esther Brunner
 * SPDX-License-Identifier: BSD-3-Clause
 */
let t=null;const e=new WeakMap,n=t=>"function"==typeof t,s=(t,e,s)=>{if(!n(t))throw new TypeError(`${s} in ${e.localName} is not a function`);return!0},r=(t,e,n,s)=>{Object.hasOwn(t,e)?t[e]=n:Object.defineProperty(t,e,s)},a=t=>(!e.has(t)&&e.set(t,new Set),e.get(t));export default class extends HTMLElement{attrs={};attributeChangedCallback(t,e,s){if(s!==e){const r=e=>Array.isArray(e)?e:[t,e],[a,i]=r(this.attrs[t]);this.cause(a,(()=>{if(n(i))return i(s,e);const t={boolean:t=>"string"==typeof t,integer:t=>parseInt(t,10),number:t=>parseFloat(t)};return t[i]?t[i](s):s}))}}has(t){return Object.hasOwn(this,t)}cause(e,s){const i=()=>(t&&a(i).add(t),n(s)?s():s);r(this,e,s,{get:()=>i(),set(t){const e=s;(s=n(t)?t(s):t)!==e&&a(i).forEach((t=>t()))}})}pass(t,e,n){r(t,e,this[n],Object.getOwnPropertyDescriptor(this,n))}derive(t,e,n){s(n,this,"Derive callback"),r(t,e,n.call(this),{get:n.bind(this)})}async effect(e){s(e,this,"Effect handler");const r=()=>{t=r;const s=e();n(s)&&setTimeout(s),t=null};return new Promise((t=>requestAnimationFrame(t))).then(r)}}