const t=t=>"function"==typeof t,e=(t,...s)=>{const n=s.shift();return!t.has(n)&&t.set(n,new Map),s.length?e(t.get(n),...s):t.get(n)},s=t=>{const e=[];for(const[n,a]of t)a instanceof Map?e.push(n,...s(a)):e.push(n,a);return e};let n;const a=e=>{const s=()=>(n&&s.effects.add(n),e);return s.effects=new Set,s.set=n=>{const a=e;if(e=t(n)&&!t(e.set)?n(a):n,!Object.is(e,a))for(const t of s.effects)t()},s},o=a=>{const o=new Map,r=(t,s,n,a)=>e(o,t,s).set(n,a),c=()=>queueMicrotask((()=>{const e=n;n=c;const i=a(r);n=e;const[f,h,u,l]=s(o);t(h)&&h(f,u,l),t(i)&&i()}));c.targets=o,c()},r=e=>t(e)?r(e()):e,c=t=>"string"==typeof t,i=t=>parseInt(t,10),f=t=>parseFloat(t),h=t=>t;export default class u extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(e,s,n){if(n!==s){const a=this.attributeMap[e],[o,r]=Array.isArray(a)?a:[e,a];this.set(o,t(r)?r(n,this,s):n)}}has(t){return this.#t.has(t)}get(t){return r(this.#t.get(t))}set(e,s,n=!0){if(this.#t.has(e)){const a=this.#t.get(e);n&&t(a.set)&&a.set(s)}else{const n=t(s)&&t(s.set)?s:a(s);this.#t.set(e,n)}}delete(t){return this.#t.delete(t)}async pass(e,s,n=customElements){await n.whenDefined(e.localName);for(const[n,o]of Object.entries(s))e.set(n,a(t(o)?o:this.#t.get(o)))}targets(t){const e=new Set;for(const s of this.#t.get(t).effects)for(const t of s.targets.keys())e.add(t);return e}}export{o as effect,c as asBoolean,i as asInteger,f as asNumber,h as asString,r as unwrap};