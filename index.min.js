const t=t=>e=>typeof e===t,e=t("string"),s=t("object"),r=t("function"),n=t=>null==t,o=t=>null!=t,a=(t,e)=>(t=>o(t)&&(s(t)||r(t)))(t)&&Symbol.toStringTag in t&&t[Symbol.toStringTag]===e,i=t=>t.nodeType!==Node.COMMENT_NODE,c=()=>({[Symbol.toStringTag]:"None",map:()=>c(),flatMap:()=>c(),filter:()=>c(),or:t=>l(t),get:()=>{}}),l=t=>({[Symbol.toStringTag]:"Ok",value:t,map:e=>l(e(t)),flatMap:e=>e(t),filter:e=>e(t)?l(t):c(),or:()=>l(t),get:()=>t}),g=t=>o(t)?l(t):c(),u="warn",h="error",d=(t,e,s="debug")=>([h,u].includes(s)&&console[s](e,t),t),p="State",b="Computed";let m;const{enqueue:f,cleanup:y}=(()=>{const t=new Map,e=new Map;let s;const r=(t,e)=>{try{t()}catch(t){d(t,e,h)}},n=()=>{s=null,t.forEach(((t,e)=>t.forEach(((t,s)=>r(t(e),`Effect ${s} on ${e?.localName||"unknown"} failed`))))),t.clear(),e.forEach((t=>r(t,"Cleanup failed"))),e.clear()},o=t=>(e,r)=>{const o=!t.has(e);t.set(e,r),o&&(s&&cancelAnimationFrame(s),s=requestAnimationFrame(n))};return queueMicrotask(n),{enqueue:(e,s,r)=>{return o((n=e,t.has(n)||t.set(n,new Map),t.get(n)))(s,r);var n},cleanup:o(e)}})(),S=t=>{m&&t.add(m)},v=t=>t.forEach((t=>t())),E=(t,e)=>{const s=m;m=e;try{t()}catch(t){d(t,"Error during reactive computation",h)}finally{m=s}},w=t=>a(t,p),x=t=>w(t)||(t=>a(t,b))(t),C=t=>{const e=new Set;return{[Symbol.toStringTag]:p,get:()=>(S(e),t),set(s){const n=t;t=r(s)&&s.length?s(t):s,Object.is(t,n)||v(e)}}},M=(t,e=!1)=>{const s=new Set;let r,o=!0;const a=()=>{o=!0,e&&v(s)};return{[Symbol.toStringTag]:b,get:()=>(S(s),e&&!o||E((()=>{r=t(),o=n(r)}),a),r)}},N=t=>{const e=()=>E((()=>{const e=t(f);r(e)&&y(t,e)}),e);e()},T=(t,e,s,n=void 0)=>{const o=t.constructor.attributeMap[e];return r(o)?o(g(s),t,n).get():s},A=(t,e=t)=>({[Symbol.toStringTag]:"UI",host:t,target:e}),k="context-request";class O extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(k,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const q=t=>async e=>{await e.host.constructor.registry.whenDefined(e.target.localName);for(const[s,n=s]of Object.entries(t))e.target.set(s,x(n)?n:r(n)?C(n):e.host.signals.get(n));return e},$=(t,e)=>s=>(s.target.addEventListener(t,e),s),F=(t,e)=>s=>(s.target.removeEventListener(t,e),s),L=(t,e=t)=>s=>(N((()=>{s.target.dispatchEvent(new CustomEvent(t,{detail:s.host.get(e),bubbles:!0}))})),s),j=t=>g(o(t.get())),P=t=>t.map((t=>parseInt(t,10))).filter(Number.isFinite),D=t=>t.map(parseFloat).filter(Number.isFinite),I=t=>t,J=t=>{try{return t.map((t=>JSON.parse(t)))}catch(t){return d(t,"Failed to parse JSON",h),c()}},H=(t,s,o,a,i,c)=>{const l=a();return r(s)||t.host.set(s,e(s)&&e(l)?T(t.host,s,l):l,!1),N((e=>{const g=a(),u=r(s)?s(g):t.host.get(s);Object.is(u,g)||e(t.target,o,c&&(t=>null===t)(u)?c:n(u)?i(l):i(u))})),t},R=t=>e=>H(e,t,"t",(()=>e.target.textContent||""),(t=>e=>()=>{Array.from(e.childNodes).filter(i).forEach((t=>t.remove())),e.append(document.createTextNode(t))})),U=(t,e=t)=>s=>H(s,e,`p-${String(t)}`,(()=>s.target[t]),(e=>s=>()=>s[t]=e)),V=(t,e=t)=>s=>H(s,e,`a-${t}`,(()=>s.target.getAttribute(t)),(e=>s=>()=>s.setAttribute(t,e)),(e=>()=>e.removeAttribute(t))),_=(t,e=t)=>s=>H(s,e,`a-${t}`,(()=>s.target.hasAttribute(t)),(e=>s=>()=>s.toggleAttribute(t,e))),z=(t,e=t)=>s=>H(s,e,`c-${t}`,(()=>s.target.classList.contains(t)),(e=>s=>()=>s.classList.toggle(t,e))),B=(t,e=t)=>s=>H(s,e,`s-${t}`,(()=>s.target.style.getPropertyValue(t)),(e=>s=>()=>s.style.setProperty(t,e)),(e=>()=>e.style.removeProperty(t)));class G extends HTMLElement{static registry=customElements;static attributeMap={};static observedAttributes;static consumedContexts;static providedContexts;static define(t){try{this.registry.get(t)||this.registry.define(t,this)}catch(e){d(t,e.message,h)}}signals=new Map;internals;self=(t=>l(A(t)))(this);root=this.shadowRoot||this;attributeChangedCallback(t,e,s){s!==e&&this.set(t,T(this,t,s,e))}connectedCallback(){(t=>{const e=t.constructor,s=e.consumedContexts||[];for(const e of s)t.set(String(e),void 0,!1);setTimeout((()=>{for(const e of s)t.dispatchEvent(new O(e,(s=>t.set(String(e),s))))}));const n=e.providedContexts||[];n.length&&t.addEventListener(k,(e=>{const{context:s,callback:o}=e;n.includes(s)&&r(o)&&(e.stopPropagation(),o(t.signals.get(String(s))))}))})(this)}disconnectedCallback(){}has(t){return this.signals.has(t)}get(t){const e=t=>r(t)?e(t()):x(t)?e(t.get()):t;return e(this.signals.get(t))}set(t,e,s=!0){if(this.signals.has(t)){if(s){const s=this.signals.get(t);w(s)&&s.set(e)}}else this.signals.set(t,w(e)?e:C(e))}delete(t){return this.signals.delete(t)}first=(t=>e=>g(t.root.querySelector(e)).map((e=>A(t,e))))(this);all=(t=>e=>Array.from(t.root.querySelectorAll(e)).map((e=>A(t,e))))(this)}export{G as UIElement,j as asBoolean,P as asInteger,J as asJSON,D as asNumber,I as asString,M as computed,N as effect,L as emit,d as log,g as maybe,F as off,$ as on,q as pass,V as setAttribute,U as setProperty,B as setStyle,R as setText,_ as toggleAttribute,z as toggleClass};
