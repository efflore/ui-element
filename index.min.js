const t=t=>"function"==typeof t;let e;const s=s=>{const n=()=>(e&&n.e.add(e),s);return n.e=new Set,n.set=e=>{const a=s;if(s=t(e)&&!t(s.set)?e(a):e,!Object.is(s,a))for(const t of n.e)t()},n};export default class extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(e,s,n){if(n!==s){const a=this.attributeMap[e],[o,r]=Array.isArray(a)?a:[e,a],c={boolean:t=>"string"==typeof t,integer:t=>parseInt(t,10),number:t=>parseFloat(t)},i=t(r)?r:c[r];this.set(o,i?i(n,s):n)}}has(t){return this.#t.has(t)}get(e){const s=e=>t(e)?s(e()):e;return s(this.#t.get(e))}set(e,n,a=!0){if(this.#t.has(e)){const s=this.#t.get(e);a&&t(s.set)&&s.set(n)}else{const a=t(n)&&t(n.set)?n:s(n);this.#t.set(e,a)}}delete(t){return this.#t.delete(t)}pass(e,n,a=customElements){a.whenDefined(e.localName).then((()=>{for(const[a,o]of Object.entries(n))e.set(a,s(t(o)?o:this.#t.get(o)))}))}effect(s){s.targets=new Map;const n=(t,e,n,a)=>{!s.targets.has(t)&&s.targets.set(t,new Map);const o=s.targets.get(t);!o.has(e)&&o.set(e,new Map);const r=o.get(e);return n&&r.set(n,a),r},a=()=>{queueMicrotask((()=>{const o=e;e=a;const r=s(n);e=o;for(const[t,e]of s.targets.entries())for(const[s,n]of e.entries())for(const[e,a]of n.entries())s(t,e,a);t(r)&&r()}))};a()}}