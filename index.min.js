const t=t=>"function"==typeof t;let e;const s=s=>{const n=()=>(e&&n.e.add(e),s);return n.e=new Set,n.set=e=>{const a=s;if(s=t(e)&&!t(s.set)?e(a):e,!Object.is(s,a))for(const t of n.e)t()},n},n=e=>t(e)?n(e()):e,a=s=>{const n=new Map,a=(t,e,s,a)=>{!n.has(t)&&n.set(t,new Map);const o=n.get(t);!o.has(e)&&o.set(e,new Map);const r=o.get(e);s&&r.set(s,a)},o=()=>queueMicrotask((()=>{const r=e;e=o;const c=s(a);e=r;for(const[t,e]of n.entries())for(const[s,n]of e.entries())for(const[e,a]of n.entries())s(t,e,a);t(c)&&c()}));o.targets=n,o()},o=t=>"string"==typeof t,r=t=>parseInt(t,10),c=t=>parseFloat(t),i=t=>t;export default class f extends HTMLElement{static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(e,s,n){if(n!==s){const a=this.attributeMap[e],[o,r]=Array.isArray(a)?a:[e,a];this.set(o,t(r)?r(n,this,s):n)}}has(t){return this.#t.has(t)}get(t){return n(this.#t.get(t))}set(e,n,a=!0){if(this.#t.has(e)){const s=this.#t.get(e);a&&t(s.set)&&s.set(n)}else{const a=t(n)&&t(n.set)?n:s(n);this.#t.set(e,a)}}delete(t){return this.#t.delete(t)}async pass(e,n,a=customElements){await a.whenDefined(e.localName);for(const[a,o]of Object.entries(n))e.set(a,s(t(o)?o:this.#t.get(o)))}targets(t){const e=new Set;for(const s of this.#t.get(t).e)for(const t of s.targets.keys())e.add(t);return e}}export{a as effect,o as asBoolean,r as asInteger,c as asNumber,i as asString,n as unwrap};