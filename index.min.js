const t=(e="function",t=>typeof t===e);var e;const s="nothing",n=e=>t(e)?n(e()):e,o=e=>t(e)&&"type"in e,c=(t,e)=>o(e)&&e.type===t,a=t=>(t=>(t=>null==t)(t)||c(s,t))(t)?i():r(t),r=t=>{const e=()=>t;return e.type=typeof t,e.or=e=>t,e.map=e=>a(e(t)),e.chain=e=>e(t),e.filter=e=>e(t)?r(t):i(),e},i=()=>new Proxy((()=>{}),{get:(t,e)=>{switch(e){case"type":return s;case"toString":return()=>"";case"or":return t=>t;case"chain":return t=>t();default:return()=>i()}}}),f="state";let u;const h=t=>c(f,t),l=t=>h(t)||(t=>c("computed",t))(t),d=e=>{const s=()=>(u&&s.effects.add(u),e);return s.type=f,s.effects=new Set,s.set=c=>{const a=e;e=t(c)&&!o(c)?(t=>o(t)&&"map"in t)(e)?e.map(c):c(e):c,!Object.is(n(e),n(a))&&(t=>{for(const e of t)e.run()})(s.effects)},s},p=e=>{const s=new Map,n=()=>{const o=u;u=n;const c=e(((t,e)=>{!s.has(t)&&s.set(t,new Set),s.get(t)?.add(e)}));for(const t of s.values()){for(const e of t)e();t.clear()}u=o,t(c)&&queueMicrotask(c)};n.type="effect",n.run=()=>n(),n.targets=s,n()},g="context-request";class b extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(g,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}class m extends HTMLElement{static consumedContexts;static providedContexts;static define(t,e=customElements){try{e.get(t)||e.define(t,this)}catch(t){console.error(t)}}attributeMap={};#t=new Map;attributeChangedCallback(e,s,n){if(n===s)return;const o=this.attributeMap[e],c=a(n);this.set(e,t(o)?c.map((t=>o(t,this,s))):c)}connectedCallback(){const e=this.constructor,s=e.consumedContexts||[];for(const t of s)this.set(String(t),void 0);setTimeout((()=>{for(const t of s)this.dispatchEvent(new b(t,(e=>this.set(String(t),e))))}));const n=e.providedContexts||[];n.length&&this.addEventListener(g,(e=>{const{context:s,callback:o}=e;n.includes(s)&&t(o)&&(e.stopPropagation(),o(this.#t.get(String(s))))}))}has(t){return this.#t.has(t)}get(t){return n(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){if(s){const s=this.#t.get(t);h(s)&&s.set(e)}}else this.#t.set(t,l(e)?e:d(e))}delete(t){return this.#t.delete(t)}async pass(e,s,n=customElements){await n.whenDefined(e.localName);for(const[n,o]of Object.entries(s))e.set(n,l(o)?o:t(o)?d(o):this.#t.get(o))}targets(t){const e=new Set,s=this.#t.get(t);if(!s||!s.effects)return e;for(const t of s.effects){const s=t.targets?.keys();if(s)for(const t of s)e.add(t)}return e}}export{m as default,p as effect};