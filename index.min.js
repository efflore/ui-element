const t=t=>e=>typeof e===t,e=t("string"),s=t("object"),r=t("function"),n=t=>null==t,a=t=>null!=t,o=t=>t.nodeType!==Node.COMMENT_NODE,c=t=>n(t)?[]:[t],i="warn",l="error",u=(t,e,s="debug")=>([l,i].includes(s)&&console[s](e,t),t);let h;const{enqueue:g,cleanup:d}=(()=>{const t=new Map,e=new Map;let s;const r=(t,e)=>{try{t()}catch(t){u(t,e,l)}},n=()=>{s=null,t.forEach(((t,e)=>t.forEach(((t,s)=>r(t(e),`Effect ${s} on ${e?.localName||"unknown"} failed`))))),t.clear(),e.forEach((t=>r(t,"Cleanup failed"))),e.clear()},a=t=>(e,r)=>{const a=!t.has(e);t.set(e,r),a&&(s&&cancelAnimationFrame(s),s=requestAnimationFrame(n))};return queueMicrotask(n),{enqueue:(e,s,r)=>{return a((n=e,t.has(n)||t.set(n,new Map),t.get(n)))(s,r);var n},cleanup:a(e)}})(),p=t=>{h&&t.add(h)},m=t=>t.forEach((t=>t())),b=(t,e)=>{const s=h;h=e;try{t()}catch(t){u(t,"Error during reactive computation",l)}finally{h=s}},f=t=>(t=>a(t)&&(s(t)||r(t)))(t)&&r(t["set"]),y=t=>{const e=new Set,s=()=>(p(e),t);return s.set=s=>{const n=t;t=r(s)&&s.length?s(t):s,Object.is(t,n)||m(e)},s},v=(t,e=!1)=>{const s=new Set;let r,a=!0;const o=()=>{a=!0,e&&m(s)};return()=>(p(s),e&&!a||b((()=>{r=t(),a=n(r)}),o),r)},E=t=>{const e=()=>b((()=>{const e=t(g);r(e)&&d(t,e)}),e);e()},w=(t,e,s,n=void 0)=>{const a=t.constructor.attributeMap[e];return r(a)?a(c(s),t,n)[0]:s},x="context-request";class C extends Event{context;callback;subscribe;constructor(t,e,s=!1){super(x,{bubbles:!0,composed:!0}),this.context=t,this.callback=e,this.subscribe=s}}const N=t=>async e=>{await e.host.constructor.registry.whenDefined(e.target.localName);for(const[s,n]of Object.entries(t))e.target.set(s,f(n)?n:r(n)?y(n):e.host.signal(n));return e},A=(t,e)=>s=>(s.target.addEventListener(t,e),s),M=(t,e)=>s=>(s.target.removeEventListener(t,e),s),S=(t,e=t)=>s=>(E((()=>{s.target.dispatchEvent(new CustomEvent(t,{detail:s.host.get(e),bubbles:!0}))})),s),k=t=>[a(t[0])],q=t=>t.map((t=>parseInt(t,10))).filter(Number.isFinite),L=t=>t.map(parseFloat).filter(Number.isFinite),$=t=>t,F=t=>{let e=[];try{e=t.map((t=>JSON.parse(t)))}catch(t){u(t,"Failed to parse JSON",l)}return e},O=(t,s,a,o,c,i)=>(r(s)||t.host.set(s,e(s)&&e(o)?w(t.host,s,o):o,!1),E((e=>{const o=r(s)?s():t.host.get(s);e(t.target,a,n(o)?c:i(o))})),t),T=t=>e=>{const s=e.target.textContent||"",r=t=>e=>()=>{Array.from(e.childNodes).filter(o).forEach((t=>t.remove())),e.append(document.createTextNode(t))};return O(e,t,"t",s,r(s),r)},j=(t,e=t)=>s=>{const r=e=>s=>()=>s[t]=e;return O(s,e,`p-${String(t)}`,s.target[t],r(null),r)},D=(t,e=t)=>s=>O(s,e,`a-${t}`,s.target.getAttribute(t),(e=>()=>e.removeAttribute(t)),(e=>s=>()=>s.setAttribute(t,e))),J=(t,e=t)=>s=>{const r=e=>s=>()=>s.toggleAttribute(t,e);return O(s,e,`a-${t}`,s.target.hasAttribute(t),r(!1),r)},P=(t,e=t)=>s=>O(s,e,`c-${t}`,s.target.classList.contains(t),(e=>()=>e.classList.remove(t)),(e=>s=>()=>s.classList.toggle(t,e))),H=(t,e=t)=>s=>O(s,e,`s-${t}`,s.target.style[t],(e=>()=>e.style.removeProperty(t)),(e=>s=>()=>s.style[t]=e));class I extends HTMLElement{static registry=customElements;static attributeMap={};static consumedContexts;static providedContexts;static define(t){try{this.registry.get(t)||this.registry.define(t,this)}catch(e){u(t,e.message,l)}}#t=new Map;self=[{host:this,target:this}];root=this.shadowRoot||this;attributeChangedCallback(t,e,s){s!==e&&this.set(t,w(this,t,s,e))}connectedCallback(){(t=>{const e=t.constructor,s=e.consumedContexts||[];for(const e of s)t.set(String(e),void 0,!1);setTimeout((()=>{for(const e of s)t.dispatchEvent(new C(e,(s=>t.set(String(e),s))))}));const n=e.providedContexts||[];n.length&&t.addEventListener(x,(e=>{const{context:s,callback:a}=e;n.includes(s)&&r(a)&&(e.stopPropagation(),a(t.get(String(s))))}))})(this)}disconnectedCallback(){}has(t){return this.#t.has(t)}get(t){const e=t=>r(t)?e(t()):t;return e(this.#t.get(t))}set(t,e,s=!0){if(this.#t.has(t)){if(s){const s=this.#t.get(t);f(s)&&s.set(e)}}else this.#t.set(t,f(e)?e:y(e))}delete(t){return this.#t.delete(t)}signal(t){return this.#t.get(t)}first(t){return c(this.root.querySelector(t)).map((t=>({host:this,target:t})))}all(t){return Array.from(this.root.querySelectorAll(t)).map((t=>({host:this,target:t})))}}export{I as UIElement,k as asBoolean,q as asInteger,F as asJSON,L as asNumber,$ as asString,v as derive,E as effect,S as emit,u as log,c as maybe,M as off,A as on,N as pass,D as setAttribute,j as setProperty,H as setStyle,T as setText,J as toggleAttribute,P as toggleClass};
