let t;const s=(t,s)=>typeof s===t,e=t=>s("function",t),n=t=>e(t)&&e(t.set),o=s=>{const o=()=>(t&&o.effects.add(t),s);return o.effects=new Set,o.set=t=>{const c=s;s=e(t)&&!n(t)?t(c):t,!Object.is(s,c)&&(t=>{for(const s of t)s.run()})(o.effects)},o},c=s=>{const n=new Map,o=()=>{const c=t;t=o;const a=s(((t,s)=>{!n.has(t)&&n.set(t,new Set),n.get(t)?.add(s)}));for(const t of n.values())for(const s of t)s();t=c,e(a)&&queueMicrotask(a)};o.run=()=>o(),o.targets=n,o()},a="context-request";class r extends Event{context;callback;subscribe;constructor(t,s,e=!1){super(a,{bubbles:!0,composed:!0}),this.context=t,this.callback=s,this.subscribe=e}}const i=(t,s)=>Array.isArray(t)?t:[s,e(t)?t:t=>t],f=t=>s("string",t);class h extends HTMLElement{static consumedContexts;static providedContexts;static define(t,s=customElements){try{s.get(t)||s.define(t,this)}catch(t){console.error(t)}}attributeMap={};contextMap={};#t=new Map;attributeChangedCallback(t,s,n){if(n===s)return;const[o,c]=i(this.attributeMap[t],t);this.set(o,e(c)?c(n,this,s):n)}connectedCallback(){const t=this.constructor,s=t.consumedContexts||[];for(const t of s)f(t)&&this.set(t,void 0);setTimeout((()=>{for(const t of s)f(t)&&this.dispatchEvent(new r(t,(s=>{const[n,o]=i(this.contextMap[t],t);this.set(n||t,e(o)?o(s,this):s)})))}));const n=t.providedContexts||[];n.length&&this.addEventListener(a,(t=>{const{context:s,callback:o}=t;f(s)&&n.includes(s)&&e(o)&&(t.stopPropagation(),o(this.#t.get(s)))}))}has(t){return this.#t.has(t)}get(t){const s=t=>e(t)?s(t()):t;return s(this.#t.get(t))}set(t,s,e=!0){if(this.#t.has(t)){const o=this.#t.get(t);e&&n(o)&&o.set(s)}else this.#t.set(t,n(s)?s:o(s))}delete(t){return this.#t.delete(t)}async pass(t,s,n=customElements){await n.whenDefined(t.localName);for(const[n,c]of Object.entries(s))t.set(n,o(e(c)?c:this.#t.get(c)))}targets(t){const s=new Set,e=this.#t.get(t);if(!e||!e.effects)return s;for(const t of e.effects){const e=t.targets?.keys();if(e)for(const t of e)s.add(t)}return s}}export{h as default,c as effect};